{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Pydantic Argparse      <p> Typed Argument Parsing with Pydantic </p>"},{"location":"#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> is a Python package built on top of <code>pydantic</code> which provides declarative typed argument parsing using <code>pydantic</code> models.</p>"},{"location":"#requirements","title":"Requirements","text":"<p><code>pydantic-argparse</code> requires Python 3.8+, and is compatible with the Pydantic v1 API.</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation with <code>pip</code> is simple: <pre><code>$ pip install pydantic-argparse\n</code></pre></p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#define-model","title":"Define Model","text":"simple.py<pre><code>\"\"\"Simple Example.\"\"\"\n\nimport pydantic.v1 as pydantic\n\nimport pydantic_argparse\n\n\nclass Arguments(pydantic.BaseModel):\n    \"\"\"Simple Command-Line Arguments.\"\"\"\n\n    # Required Args\n    string: str = pydantic.Field(description=\"a required string\")\n    integer: int = pydantic.Field(description=\"a required integer\")\n    flag: bool = pydantic.Field(description=\"a required flag\")\n\n    # Optional Args\n    second_flag: bool = pydantic.Field(False, description=\"an optional flag\")\n    third_flag: bool = pydantic.Field(True, description=\"an optional flag\")\n\n\ndef main() -&gt; None:\n    \"\"\"Simple Main Function.\"\"\"\n    # Create Parser and Parse Args\n    parser = pydantic_argparse.ArgumentParser(\n        model=Arguments,\n        prog=\"Example Program\",\n        description=\"Example Description\",\n        version=\"0.0.1\",\n        epilog=\"Example Epilog\",\n    )\n    args = parser.parse_typed_args()\n\n    # Print Args\n    print(args)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#check-help","title":"Check Help","text":"<pre><code>$ python3 simple.py --help\nusage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag |\n                       --no-flag [--second-flag] [--no-third-flag]\n\nExample Description\n\nrequired arguments:\n  --string STRING    a required string\n  --integer INTEGER  a required integer\n  --flag, --no-flag  a required flag\n\noptional arguments:\n  --second-flag      an optional flag (default: False)\n  --no-third-flag    an optional flag (default: True)\n\nhelp:\n  -h, --help         show this help message and exit\n  -v, --version      show program's version number and exit\n\nExample Epilog\n</code></pre>"},{"location":"#parse-arguments","title":"Parse Arguments","text":"<pre><code>$ python3 simple.py --string hello --integer 42 --flag\nstring='hello' integer=42 flag=True second_flag=False third_flag=True\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This project is made possible by <code>pydantic</code>.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#overview","title":"Overview","text":"<p>Before delving into the documentation, examples and code reference, it is first necessary to explore and understand why you may want to use this package.</p>"},{"location":"background/#tenets","title":"Tenets","text":"<p>The design goals of <code>pydantic-argparse</code> are summarised by these core tenets.</p>"},{"location":"background/#simple","title":"Simple","text":"<code>pydantic-argparse</code> has a simple API and code-base."},{"location":"background/#opinionated","title":"Opinionated","text":"<code>pydantic-argparse</code> is deliberately limited with one way of doing things."},{"location":"background/#typed","title":"Typed","text":"<code>pydantic-argparse</code> fully supports type-hinting and <code>mypy</code>."},{"location":"background/#rationale","title":"Rationale","text":"<p>There are many benefits to using <code>pydantic-argparse</code> over a more traditional argument parsing package that uses a functional api. Some of the most valuable benefits are outlined below.</p>"},{"location":"background/#declarative-arguments","title":"Declarative Arguments","text":"<p>Arguments are defined declaratively using <code>pydantic</code> models. This means the command-line interface for your application has a strict schema, that is easy to view, modify or even export to other formats such as <code>JSON Schema</code>.</p>"},{"location":"background/#familiar-syntax","title":"Familiar Syntax","text":"<p>Due to the use of <code>pydantic</code> models and standard type-hinting, there is almost no new syntax or API to learn. Just declare your interface with a dataclass-like <code>pydantic</code> model, and let <code>pydantic-argparse</code> parse your arguments.</p>"},{"location":"background/#type-hints","title":"Type Hints","text":"<p>Due to the use of <code>pydantic</code> models, your parsed command-line arguments are just an instance of a type-hinted class. This means that your arguments can support auto-completion, linting, mypy and other tools in your IDE.</p>"},{"location":"background/#pydantic-validation","title":"Pydantic Validation","text":"<p>Due to the use of <code>pydantic</code> models, your command-line interface is able to heavily leverage <code>pydantic</code>'s validation system to provide a very large number of different types.</p>"},{"location":"background/#confidence","title":"Confidence","text":"<p>As a result of type-hinting and <code>pydantic</code> validation, you can have the confidence that once your command-line arguments have been parsed, their type and validity have been confirmed - you don't have to check or worry about them again.</p>"},{"location":"background/#drawbacks","title":"Drawbacks","text":"<p>There are also some drawbacks to using <code>pydantic-argparse</code>, depending on the size of your project, the features you require and the programming paradigms that you agree with. Some of the possible drawbacks are outlined below.</p>"},{"location":"background/#extra-dependencies","title":"Extra Dependencies","text":"<p>While <code>pydantic-argparse</code> itself depends only on <code>pydantic</code>, it has a number of transient dependencies due to the dependencies of <code>pydantic</code> itself. If your application is small, it may not be suitable to pull in <code>pydantic</code> and its dependencies for a simple command-line interface.</p>"},{"location":"background/#opinionated-design","title":"Opinionated Design","text":"<p><code>pydantic-argparse</code> is a very opinionated package by design. It aims for a simple API, and to be both full featured while limiting excessive choices. For example, there are no positional arguments in <code>pydantic-argparse</code>; only optional and required arguments. If your opinions do not align with these design choices, then you may not want to use the package.</p>"},{"location":"background/#nested-models","title":"Nested Models","text":"<p>Sub-commands are supported by nesting <code>pydantic</code> models. This means that for each sub-command, an additional model must be defined. If your application requires many different sub-commands, it may result in a large number of <code>pydantic</code> models.</p>"},{"location":"background/#alternatives","title":"Alternatives","text":"<p>There are many alternative argument parsing packages that already exist for Python. Some of the most popular are outlined below.</p>"},{"location":"background/#argparse","title":"Argparse","text":"<p><code>argparse</code> is a standard-library module that makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and <code>argparse</code> will figure out how to parse those out of <code>sys.argv</code>. The <code>argparse</code> module also automatically generates help and usage messages and issues errors when users give the program invalid arguments.</p>"},{"location":"background/#click","title":"Click","text":"<p><code>click</code> is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box.</p>"},{"location":"background/#typer","title":"Typer","text":"<p><code>typer</code> is a library for building CLI applications that users will love using and developers will love creating. Based on Python 3.6+ type hints. The key features are that it is intuitive to write, easy to use, short and starts simple but can grow large. It aims to be the <code>fastapi</code> of command-line interfaces.</p>"},{"location":"background/#comparison","title":"Comparison","text":"<p>A feature comparison matrix of the alternatives outlined above is shown below.</p> <code>argparse</code> <code>click</code> <code>typer</code> <code>pydantic-argparse</code> Arguments Optional Arguments Required Arguments Positional Arguments Sub-Commands Argument Types Regular Arguments Variadic Arguments Flag Arguments Choice Arguments Validation Type Validation Automatic Validation Pydantic Validation Design Pattern Functional Definition Declarative Definition Function Decorators Function Signature Inspection Extra Features Typing Hinting Shell Completion Environment Variables"},{"location":"showcase/","title":"Showcase","text":""},{"location":"showcase/#feature-showcase","title":"Feature Showcase","text":"<p>This showcase demonstrates how <code>pydantic-argparse</code> can be useful, by highlighting some of its features and showing how they can be utilised.</p>"},{"location":"showcase/#cli-construction","title":"CLI Construction","text":"<p>The <code>pydantic-argparse</code> command-line interface construction is simple.</p> Pydantic ArgparseArgparse <pre><code>import pydantic.v1 as pydantic\n\nimport pydantic_argparse\n\n# Declare Arguments\nclass Arguments(pydantic.BaseModel):\n    # Required Arguments\n    string: str = pydantic.Field(description=\"a required string\")\n    integer: int = pydantic.Field(description=\"a required integer\")\n    flag: bool = pydantic.Field(description=\"a required flag\")\n\n    # Optional Arguments\n    second_flag: bool = pydantic.Field(False, description=\"an optional flag\")\n    third_flag: bool = pydantic.Field(True, description=\"an optional flag\")\n\n# Create Parser\nparser = pydantic_argparse.ArgumentParser(\n    model=Arguments,\n    prog=\"Example Program\",\n    description=\"Example Description\",\n    version=\"0.0.1\",\n    epilog=\"Example Epilog\",\n)\n\n# Parse Arguments\nargs = parser.parse_typed_args()\n</code></pre> <pre><code>import argparse\n\n# Create Parser\nparser = argparse.ArgumentParser(\n    prog=\"Example Program\",\n    description=\"Example Description\",\n    epilog=\"Example Epilog\",\n    add_help=False,\n)\n\n# Functionally Add Argument Groups\nrequired = parser.add_argument_group(title=\"required arguments\")\noptional = parser.add_argument_group(title=\"optional arguments\")\nhelp = parser.add_argument_group(\"help\")\n\n# Add Help Actions\nhelp.add_argument(\n    \"-h\",\n    \"--help\",\n    action=\"help\",\n    help=\"show this help message and exit\",\n)\nhelp.add_argument(\n    \"-v\",\n    \"--version\",\n    action=\"version\",\n    version=\"0.0.1\",\n    help=\"show program's version number and exit\",\n)\n\n# Add Required Arguments\nrequired.add_argument(\n    \"--string\",\n    type=str,\n    required=True,\n    help=\"a required string\",\n)\nrequired.add_argument(\n    \"--integer\",\n    type=int,\n    required=True,\n    help=\"a required integer\",\n)\nrequired.add_argument(\n    \"--flag\",\n    action=argparse.BooleanOptionalAction,\n    required=True,\n    help=\"a required flag\",\n)\n\n# Add Optional Arguments\noptional.add_argument(\n    \"--second-flag\",\n    action=\"store_true\",\n    help=\"an optional flag (default: False)\",\n)\noptional.add_argument(\n    \"--third-flag\",\n    action=\"store_false\",\n    help=\"an optional flag (default: True)\",\n)\n\n# Parse Arguments\nargs = parser.parse_args()\n</code></pre>"},{"location":"showcase/#auto-completion","title":"Auto Completion","text":"<p>The <code>pydantic-argparse</code> parsed <code>args</code> support auto-completion in your IDE.</p> Pydantic ArgparseArgparse <p></p> <p></p>"},{"location":"showcase/#type-hints","title":"Type Hints","text":"<p>The <code>pydantic-argparse</code> parsed <code>args</code> support type-hinting in your IDE.</p> Pydantic ArgparseArgparse <p></p> <p></p>"},{"location":"showcase/#type-safety","title":"Type Safety","text":"<p>The <code>pydantic-argparse</code> parsed <code>args</code> support type-safety with <code>mypy</code>.</p> Pydantic ArgparseArgparse <p></p> <p></p>"},{"location":"examples/commands/","title":"Commands","text":""},{"location":"examples/commands/#define-model","title":"Define Model","text":"commands.py<pre><code>\"\"\"Commands Example.\"\"\"\n\nimport pydantic.v1 as pydantic\n\nimport pydantic_argparse\n\nfrom typing import Optional\n\n\nclass BuildCommand(pydantic.BaseModel):\n    \"\"\"Build Command Arguments.\"\"\"\n\n    # Required Args\n    location: pydantic.FilePath = pydantic.Field(description=\"build location\")\n\n\nclass ServeCommand(pydantic.BaseModel):\n    \"\"\"Serve Command Arguments.\"\"\"\n\n    # Required Args\n    address: pydantic.IPvAnyAddress = pydantic.Field(description=\"serve address\")\n    port: int = pydantic.Field(description=\"serve port\")\n\n\nclass Arguments(pydantic.BaseModel):\n    \"\"\"Command-Line Arguments.\"\"\"\n\n    # Optional Args\n    verbose: bool = pydantic.Field(False, description=\"verbose flag\")\n\n    # Commands\n    build: Optional[BuildCommand] = pydantic.Field(description=\"build command\")\n    serve: Optional[ServeCommand] = pydantic.Field(description=\"serve command\")\n\n\ndef main() -&gt; None:\n    \"\"\"Main Function.\"\"\"\n    # Create Parser and Parse Args\n    parser = pydantic_argparse.ArgumentParser(\n        model=Arguments,\n        prog=\"Example Program\",\n        description=\"Example Description\",\n        version=\"0.0.1\",\n        epilog=\"Example Epilog\",\n    )\n    args = parser.parse_typed_args()\n\n    # Print Args\n    print(args)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/commands/#check-help","title":"Check Help","text":"<pre><code>$ python3 examples/commands.py --help\nusage: Example Program [-h] [-v] [--verbose] {build,serve} ...\n\nExample Description\n\ncommands:\n  {build,serve}\n    build        build command\n    serve        serve command\n\noptional arguments:\n  --verbose      verbose flag (default: False)\n\nhelp:\n  -h, --help     show this help message and exit\n  -v, --version  show program's version number and exit\n\nExample Epilog\n</code></pre>"},{"location":"examples/commands/#check-commands-help","title":"Check Commands Help","text":"<p><pre><code>$ python3 examples/commands.py build --help\nusage: Example Program build [-h] --location LOCATION\n\nrequired arguments:\n  --location LOCATION  build location\n\nhelp:\n  -h, --help           show this help message and exit\n</code></pre> <pre><code>$ python3 examples/commands.py serve --help\nusage: Example Program serve [-h] --address ADDRESS --port PORT\n\nrequired arguments:\n  --address ADDRESS  serve address\n  --port PORT        serve port\n\nhelp:\n  -h, --help         show this help message and exit\n</code></pre></p>"},{"location":"examples/commands/#parse-arguments","title":"Parse Arguments","text":"<pre><code>$ python3 examples/commands.py --verbose serve --address 127.0.0.1 --port 8080\nverbose=True build=None serve=ServeCommand(address=IPv4Address('127.0.0.1'), port=8080)\n</code></pre>"},{"location":"examples/simple/","title":"Simple","text":""},{"location":"examples/simple/#define-model","title":"Define Model","text":"simple.py<pre><code>\"\"\"Simple Example.\"\"\"\n\nimport pydantic.v1 as pydantic\n\nimport pydantic_argparse\n\n\nclass Arguments(pydantic.BaseModel):\n    \"\"\"Simple Command-Line Arguments.\"\"\"\n\n    # Required Args\n    string: str = pydantic.Field(description=\"a required string\")\n    integer: int = pydantic.Field(description=\"a required integer\")\n    flag: bool = pydantic.Field(description=\"a required flag\")\n\n    # Optional Args\n    second_flag: bool = pydantic.Field(False, description=\"an optional flag\")\n    third_flag: bool = pydantic.Field(True, description=\"an optional flag\")\n\n\ndef main() -&gt; None:\n    \"\"\"Simple Main Function.\"\"\"\n    # Create Parser and Parse Args\n    parser = pydantic_argparse.ArgumentParser(\n        model=Arguments,\n        prog=\"Example Program\",\n        description=\"Example Description\",\n        version=\"0.0.1\",\n        epilog=\"Example Epilog\",\n    )\n    args = parser.parse_typed_args()\n\n    # Print Args\n    print(args)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/simple/#check-help","title":"Check Help","text":"<pre><code>$ python3 simple.py --help\nusage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag |\n                       --no-flag [--second-flag] [--no-third-flag]\n\nExample Description\n\nrequired arguments:\n  --string STRING    a required string\n  --integer INTEGER  a required integer\n  --flag, --no-flag  a required flag\n\noptional arguments:\n  --second-flag      an optional flag (default: False)\n  --no-third-flag    an optional flag (default: True)\n\nhelp:\n  -h, --help         show this help message and exit\n  -v, --version      show program's version number and exit\n\nExample Epilog\n</code></pre>"},{"location":"examples/simple/#parse-arguments","title":"Parse Arguments","text":"<pre><code>$ python3 simple.py --string hello --integer 42 --flag\nstring='hello' integer=42 flag=True second_flag=False third_flag=True\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pydantic_argparse<ul> <li>argparse<ul> <li>actions.py</li> <li>parser.py</li> </ul> </li> <li>compatibility<ul> <li>argparse.py</li> <li>pydantic.py</li> </ul> </li> <li>parsers<ul> <li>boolean.py</li> <li>command.py</li> <li>container.py</li> <li>enum.py</li> <li>literal.py</li> <li>mapping.py</li> <li>standard.py</li> </ul> </li> <li>utils<ul> <li>arguments.py</li> <li>errors.py</li> <li>namespaces.py</li> <li>pydantic.py</li> <li>types.py</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pydantic_argparse/","title":"pydantic_argparse","text":""},{"location":"reference/pydantic_argparse/#__init__py","title":"__init__.py","text":"<p>Declarative Typed Argument Parsing with Pydantic Models.</p> <p>This is the <code>pydantic-argparse</code> package, which contains the classes, methods and functions required for declarative and typed argument parsing with <code>pydantic</code> models.</p> <p>The public interface exposed by this package is the declarative and typed <code>ArgumentParser</code> class, as well as the package \"dunder\" metadata.</p>"},{"location":"reference/pydantic_argparse/#__metadata__py","title":"__metadata__.py","text":""},{"location":"reference/pydantic_argparse/argparse/","title":"argparse","text":""},{"location":"reference/pydantic_argparse/argparse/#__init__py","title":"__init__.py","text":"<p>Declarative and Typed Argument Parsing.</p> <p>This package contains the classes and methods required for declarative and typed argument parsing.</p> <p>The public interface exposed by this package is the <code>ArgumentParser</code> class, which is intended to be a near drop-in replacement for the Python standard library <code>argparse.ArgumentParser</code> - while providing declarative and typed argument parsing.</p>"},{"location":"reference/pydantic_argparse/argparse/actions/","title":"actions","text":"<p>Recursively Nesting Sub-Parsers Action for Typed Argument Parsing.</p> <p>The <code>actions</code> module contains the <code>SubParsersAction</code> class, which is an action that provides recursive namespace nesting when parsing sub-commands. It also contains the <code>BooleanOptionalAction</code> class, which is a direct backport of the Python standard library <code>argparse</code> class of the same name.</p>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction","title":"<code> SubParsersAction        </code>","text":"<p>Recursively Nesting Sub-Parsers Action for Typed Argument Parsing.</p> <p>This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually.</p> <p>Examples:</p> <p>Construct <code>ArgumentParser</code>: <pre><code># Create Argument Parser\nparser = argparse.ArgumentParser()\n\n# Add Example Global Argument\nparser.add_argument(\"--time\")\n\n# Add SubParsersAction\nsubparsers = parser.add_subparsers()\n\n# Add Example 'walk' Command with Arguments\nwalk = subparsers.add_parser(\"walk\")\nwalk.add_argument(\"--speed\")\nwalk.add_argument(\"--distance\")\n\n# Add Example 'talk' Command with Arguments\ntalk = subparsers.add_parser(\"talk\")\ntalk.add_argument(\"--volume\")\ntalk.add_argument(\"--topic\")\n</code></pre></p> <p>Parse the Arguments: <pre><code>--time 3 walk --speed 7 --distance 42\n</code></pre></p> <p>Check Resultant Namespaces: <pre><code>Original: Namespace(time=3, speed=7, distance=42)\nCustom:   Namespace(time=3, walk=Namespace(speed=7, distance=42))\n</code></pre></p> <p>This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively.</p> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>class SubParsersAction(argparse._SubParsersAction):\n    \"\"\"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing.\n\n    This custom action differs in functionality from the existing standard\n    argparse SubParsersAction because it nests the resultant sub-namespace\n    directly into the supplied parent namespace, rather than iterating through\n    and updating the parent namespace object with each argument individually.\n\n    Example:\n        Construct `ArgumentParser`:\n        ```python\n        # Create Argument Parser\n        parser = argparse.ArgumentParser()\n\n        # Add Example Global Argument\n        parser.add_argument(\"--time\")\n\n        # Add SubParsersAction\n        subparsers = parser.add_subparsers()\n\n        # Add Example 'walk' Command with Arguments\n        walk = subparsers.add_parser(\"walk\")\n        walk.add_argument(\"--speed\")\n        walk.add_argument(\"--distance\")\n\n        # Add Example 'talk' Command with Arguments\n        talk = subparsers.add_parser(\"talk\")\n        talk.add_argument(\"--volume\")\n        talk.add_argument(\"--topic\")\n        ```\n\n        Parse the Arguments:\n        ```console\n        --time 3 walk --speed 7 --distance 42\n        ```\n\n        Check Resultant Namespaces:\n        ```python\n        Original: Namespace(time=3, speed=7, distance=42)\n        Custom:   Namespace(time=3, walk=Namespace(speed=7, distance=42))\n        ```\n\n    This behaviour results in a final namespace structure which is much easier\n    to parse, where subcommands are easily identified and nested into their own\n    namespace recursively.\n    \"\"\"\n\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: Union[str, Sequence[Any], None],\n        option_string: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Parses arguments into a namespace with the specified subparser.\n\n        This custom method parses arguments with the specified subparser, then\n        embeds the resultant sub-namespace into the supplied parent namespace.\n\n        Args:\n            parser (argparse.ArgumentParser): Parent argument parser object.\n            namespace (argparse.Namespace): Parent namespace being parsed to.\n            values (Union[str, Sequence[Any], None]): Arguments to parse.\n            option_string (Optional[str]): Optional option string (not used).\n\n        Raises:\n            argparse.ArgumentError: Raised if subparser name does not exist.\n        \"\"\"\n        # Check values object is a sequence\n        # In order to not violate the Liskov Substitution Principle (LSP), the\n        # function signature for __call__ must match the base Action class. As\n        # such, this function signature also accepts 'str' and 'None' types for\n        # the values argument. However, in reality, this should only ever be a\n        # list of strings here, so we just do a type cast.\n        values = cast(List[str], values)\n\n        # Get Parser Name and Remaining Argument Strings\n        parser_name, *arg_strings = values\n\n        # Try select the parser\n        try:\n            # Select the parser\n            parser = self._name_parser_map[parser_name]\n\n        except KeyError as exc:\n            # Parser doesn't exist, raise an exception\n            raise argparse.ArgumentError(\n                self,\n                f\"unknown parser {parser_name} (choices: {', '.join(self._name_parser_map)})\",\n            ) from exc\n\n        # Parse all the remaining options into a sub-namespace, then embed this\n        # sub-namespace into the parent namespace\n        subnamespace, arg_strings = parser.parse_known_args(arg_strings)\n        setattr(namespace, parser_name, subnamespace)\n\n        # Store any unrecognized options on the parent namespace, so that the\n        # top level parser can decide what to do with them\n        if arg_strings:\n            vars(namespace).setdefault(argparse._UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, argparse._UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction.__call__","title":"<code>__call__(self, parser, namespace, values, option_string=None)</code>  <code>special</code>","text":"<p>Parses arguments into a namespace with the specified subparser.</p> <p>This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Parent argument parser object.</p> required <code>namespace</code> <code>argparse.Namespace</code> <p>Parent namespace being parsed to.</p> required <code>values</code> <code>Union[str, Sequence[Any], None]</code> <p>Arguments to parse.</p> required <code>option_string</code> <code>Optional[str]</code> <p>Optional option string (not used).</p> <code>None</code> <p>Exceptions:</p> Type Description <code>argparse.ArgumentError</code> <p>Raised if subparser name does not exist.</p> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>def __call__(\n    self,\n    parser: argparse.ArgumentParser,\n    namespace: argparse.Namespace,\n    values: Union[str, Sequence[Any], None],\n    option_string: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Parses arguments into a namespace with the specified subparser.\n\n    This custom method parses arguments with the specified subparser, then\n    embeds the resultant sub-namespace into the supplied parent namespace.\n\n    Args:\n        parser (argparse.ArgumentParser): Parent argument parser object.\n        namespace (argparse.Namespace): Parent namespace being parsed to.\n        values (Union[str, Sequence[Any], None]): Arguments to parse.\n        option_string (Optional[str]): Optional option string (not used).\n\n    Raises:\n        argparse.ArgumentError: Raised if subparser name does not exist.\n    \"\"\"\n    # Check values object is a sequence\n    # In order to not violate the Liskov Substitution Principle (LSP), the\n    # function signature for __call__ must match the base Action class. As\n    # such, this function signature also accepts 'str' and 'None' types for\n    # the values argument. However, in reality, this should only ever be a\n    # list of strings here, so we just do a type cast.\n    values = cast(List[str], values)\n\n    # Get Parser Name and Remaining Argument Strings\n    parser_name, *arg_strings = values\n\n    # Try select the parser\n    try:\n        # Select the parser\n        parser = self._name_parser_map[parser_name]\n\n    except KeyError as exc:\n        # Parser doesn't exist, raise an exception\n        raise argparse.ArgumentError(\n            self,\n            f\"unknown parser {parser_name} (choices: {', '.join(self._name_parser_map)})\",\n        ) from exc\n\n    # Parse all the remaining options into a sub-namespace, then embed this\n    # sub-namespace into the parent namespace\n    subnamespace, arg_strings = parser.parse_known_args(arg_strings)\n    setattr(namespace, parser_name, subnamespace)\n\n    # Store any unrecognized options on the parent namespace, so that the\n    # top level parser can decide what to do with them\n    if arg_strings:\n        vars(namespace).setdefault(argparse._UNRECOGNIZED_ARGS_ATTR, [])\n        getattr(namespace, argparse._UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.BooleanOptionalAction","title":"<code> BooleanOptionalAction        </code>","text":"<p>Action for parsing paired GNU-style boolean arguments.</p> <p>This backported action provides the functionality for parsing paired GNU-style boolean arguments, such as \"--foo/--no-foo\". This style of argument allows us to easily provide required boolean arguments.</p> <p>This action was added into the Python standard library <code>argparse</code> module in <code>BPO-8538</code> and is available in Python 3.9 and above. In order to support Python 3.8 we directly backport the class and make it available here.</p> <p>Source: https://github.com/python/cpython/blob/v3.11.0/Lib/argparse.py#L878-L914</p> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>class BooleanOptionalAction(argparse.Action):  # pragma: no cover\n    \"\"\"Action for parsing paired GNU-style boolean arguments.\n\n    This backported action provides the functionality for parsing paired\n    GNU-style boolean arguments, such as \"--foo/--no-foo\". This style of\n    argument allows us to easily provide *required* boolean arguments.\n\n    This action was added into the Python standard library `argparse` module\n    in [`BPO-8538`](https://bugs.python.org/issue8538) and is available in\n    Python 3.9 and above. In order to support Python 3.8 we directly backport\n    the class and make it available here.\n\n    Source:\n    &lt;https://github.com/python/cpython/blob/v3.11.0/Lib/argparse.py#L878-L914&gt;\n    \"\"\"\n\n    def __init__(\n        self,\n        option_strings: Sequence[str],\n        dest: str,\n        default: Optional[Union[T, str]] = None,\n        type: Optional[Union[Callable[[str], T], argparse.FileType]] = None,  # noqa: A002\n        choices: Optional[Iterable[T]] = None,\n        required: bool = False,\n        help: Optional[str] = None,  # noqa: A002\n        metavar: Optional[Union[str, Tuple[str, ...]]] = None,\n    ) -&gt; None:\n        \"\"\"Instantiates the Boolean Optional Action.\n\n        This creates the default provided \"--&lt;OPT&gt;\" option strings which set\n        the argument to `True`. It also creates alternative pair \"--no-&lt;OPT&gt;\"\n        option strings which set the argument to `False`.\n\n        Args:\n            option_strings (Sequence[str]): Option strings.\n            dest (str): Destination variable to save the value to.\n            default (Optional[Union[T, str]]): Default value of the option.\n            type (Optional[Union[Callable[[str], T], argparse.FileType]]): Type\n                to cast the option to.\n            choices (Optional[Iterable[T]]): Allowed values for the option.\n            required (bool): Whether the option is required.\n            help (Optional[str]): Help string for the option.\n            metavar (Optional[Union[str, Tuple[str, ...]]]): Meta variable name\n                for the option.\n        \"\"\"\n        # Initialise intermediary option strings list\n        _option_strings = []\n\n        # Loop through passed in option strings\n        for option_string in option_strings:\n            # Append the option string to the new list\n            _option_strings.append(option_string)\n\n            # Check if this option string is a \"--&lt;OPT&gt;\" option string\n            if option_string.startswith(\"--\"):\n                # Create a \"--no-&lt;OPT&gt;\" negated option string\n                option_string = \"--no-\" + option_string[2:]\n\n                # Append the negated option string to the new list as well\n                _option_strings.append(option_string)\n\n        # Initialise Super Class\n        super().__init__(\n            option_strings=_option_strings,\n            dest=dest,\n            nargs=0,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar,\n        )\n\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        values: Optional[Union[str, Sequence[Any]]],\n        option_string: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Parses the provided boolean arguments into a namespace.\n\n        This custom method parses arguments as booleans, negating the values of\n        any arguments prepended with \"--no-\".\n\n        Args:\n            parser (argparse.ArgumentParser): Parent argument parser object.\n            namespace (argparse.Namespace): Parent namespace being parsed to.\n            values (Optional[Union[str, Sequence[Any]]]): Arguments to parse.\n            option_string (Optional[str]): Optional option string.\n        \"\"\"\n        # Check if the passed in option string matches our option strings\n        if option_string in self.option_strings:\n            # Set a boolean value on the namespace\n            # If the option string starts with \"--no-\", then negate the value\n            setattr(namespace, self.dest, not option_string.startswith(\"--no-\"))  # type: ignore[union-attr]\n\n    def format_usage(self) -&gt; str:\n        \"\"\"Formats the usage string.\n\n        Returns:\n            str: Usage string for the option.\n        \"\"\"\n        # Format and return usage string\n        return \" | \".join(self.option_strings)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.BooleanOptionalAction.__init__","title":"<code>__init__(self, option_strings, dest, default=None, type=None, choices=None, required=False, help=None, metavar=None)</code>  <code>special</code>","text":"<p>Instantiates the Boolean Optional Action.</p> <p>This creates the default provided \"--\" option strings which set the argument to <code>True</code>. It also creates alternative pair \"--no-\" option strings which set the argument to <code>False</code>. <p>Parameters:</p> Name Type Description Default <code>option_strings</code> <code>Sequence[str]</code> <p>Option strings.</p> required <code>dest</code> <code>str</code> <p>Destination variable to save the value to.</p> required <code>default</code> <code>Optional[Union[T, str]]</code> <p>Default value of the option.</p> <code>None</code> <code>type</code> <code>Optional[Union[Callable[[str], T], argparse.FileType]]</code> <p>Type to cast the option to.</p> <code>None</code> <code>choices</code> <code>Optional[Iterable[T]]</code> <p>Allowed values for the option.</p> <code>None</code> <code>required</code> <code>bool</code> <p>Whether the option is required.</p> <code>False</code> <code>help</code> <code>Optional[str]</code> <p>Help string for the option.</p> <code>None</code> <code>metavar</code> <code>Optional[Union[str, Tuple[str, ...]]]</code> <p>Meta variable name for the option.</p> <code>None</code> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>def __init__(\n    self,\n    option_strings: Sequence[str],\n    dest: str,\n    default: Optional[Union[T, str]] = None,\n    type: Optional[Union[Callable[[str], T], argparse.FileType]] = None,  # noqa: A002\n    choices: Optional[Iterable[T]] = None,\n    required: bool = False,\n    help: Optional[str] = None,  # noqa: A002\n    metavar: Optional[Union[str, Tuple[str, ...]]] = None,\n) -&gt; None:\n    \"\"\"Instantiates the Boolean Optional Action.\n\n    This creates the default provided \"--&lt;OPT&gt;\" option strings which set\n    the argument to `True`. It also creates alternative pair \"--no-&lt;OPT&gt;\"\n    option strings which set the argument to `False`.\n\n    Args:\n        option_strings (Sequence[str]): Option strings.\n        dest (str): Destination variable to save the value to.\n        default (Optional[Union[T, str]]): Default value of the option.\n        type (Optional[Union[Callable[[str], T], argparse.FileType]]): Type\n            to cast the option to.\n        choices (Optional[Iterable[T]]): Allowed values for the option.\n        required (bool): Whether the option is required.\n        help (Optional[str]): Help string for the option.\n        metavar (Optional[Union[str, Tuple[str, ...]]]): Meta variable name\n            for the option.\n    \"\"\"\n    # Initialise intermediary option strings list\n    _option_strings = []\n\n    # Loop through passed in option strings\n    for option_string in option_strings:\n        # Append the option string to the new list\n        _option_strings.append(option_string)\n\n        # Check if this option string is a \"--&lt;OPT&gt;\" option string\n        if option_string.startswith(\"--\"):\n            # Create a \"--no-&lt;OPT&gt;\" negated option string\n            option_string = \"--no-\" + option_string[2:]\n\n            # Append the negated option string to the new list as well\n            _option_strings.append(option_string)\n\n    # Initialise Super Class\n    super().__init__(\n        option_strings=_option_strings,\n        dest=dest,\n        nargs=0,\n        default=default,\n        type=type,\n        choices=choices,\n        required=required,\n        help=help,\n        metavar=metavar,\n    )\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.BooleanOptionalAction.__call__","title":"<code>__call__(self, parser, namespace, values, option_string=None)</code>  <code>special</code>","text":"<p>Parses the provided boolean arguments into a namespace.</p> <p>This custom method parses arguments as booleans, negating the values of any arguments prepended with \"--no-\".</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Parent argument parser object.</p> required <code>namespace</code> <code>argparse.Namespace</code> <p>Parent namespace being parsed to.</p> required <code>values</code> <code>Optional[Union[str, Sequence[Any]]]</code> <p>Arguments to parse.</p> required <code>option_string</code> <code>Optional[str]</code> <p>Optional option string.</p> <code>None</code> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>def __call__(\n    self,\n    parser: argparse.ArgumentParser,\n    namespace: argparse.Namespace,\n    values: Optional[Union[str, Sequence[Any]]],\n    option_string: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Parses the provided boolean arguments into a namespace.\n\n    This custom method parses arguments as booleans, negating the values of\n    any arguments prepended with \"--no-\".\n\n    Args:\n        parser (argparse.ArgumentParser): Parent argument parser object.\n        namespace (argparse.Namespace): Parent namespace being parsed to.\n        values (Optional[Union[str, Sequence[Any]]]): Arguments to parse.\n        option_string (Optional[str]): Optional option string.\n    \"\"\"\n    # Check if the passed in option string matches our option strings\n    if option_string in self.option_strings:\n        # Set a boolean value on the namespace\n        # If the option string starts with \"--no-\", then negate the value\n        setattr(namespace, self.dest, not option_string.startswith(\"--no-\"))  # type: ignore[union-attr]\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.BooleanOptionalAction.format_usage","title":"<code>format_usage(self)</code>","text":"<p>Formats the usage string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Usage string for the option.</p> Source code in <code>pydantic_argparse/argparse/actions.py</code> <pre><code>def format_usage(self) -&gt; str:\n    \"\"\"Formats the usage string.\n\n    Returns:\n        str: Usage string for the option.\n    \"\"\"\n    # Format and return usage string\n    return \" | \".join(self.option_strings)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/parser/","title":"parser","text":"<p>Declarative and Typed Argument Parser.</p> <p>The <code>parser</code> module contains the <code>ArgumentParser</code> class, which provides a declarative method of defining command-line interfaces.</p> <p>The procedure to declaratively define a typed command-line interface is:</p> <ol> <li>Define <code>pydantic</code> arguments model</li> <li>Create typed <code>ArgumentParser</code></li> <li>Parse typed arguments</li> </ol> <p>The resultant arguments object returned is an instance of the defined <code>pydantic</code> model. This means that the arguments object and its attributes will be compatible with an IDE, linter or type checker.</p>"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser","title":"<code> ArgumentParser        </code>","text":"<p>Declarative and Typed Argument Parser.</p> <p>The <code>ArgumentParser</code> declaratively generates a command-line interface using the <code>pydantic</code> model specified upon instantiation.</p> <p>The <code>ArgumentParser</code> provides the following <code>argparse</code> functionality:</p> <ul> <li>Required Arguments</li> <li>Optional Arguments</li> <li>Subcommands</li> </ul> <p>All arguments are named, and positional arguments are not supported.</p> <p>The <code>ArgumentParser</code> provides the method <code>parse_typed_args()</code> to parse command line arguments and return an instance of its bound <code>pydantic</code> model, populated with the parsed and validated user supplied command-line arguments.</p> Source code in <code>pydantic_argparse/argparse/parser.py</code> <pre><code>class ArgumentParser(argparse.ArgumentParser, Generic[PydanticModelT]):\n    \"\"\"Declarative and Typed Argument Parser.\n\n    The `ArgumentParser` declaratively generates a command-line interface using\n    the `pydantic` model specified upon instantiation.\n\n    The `ArgumentParser` provides the following `argparse` functionality:\n\n    * Required Arguments\n    * Optional Arguments\n    * Subcommands\n\n    All arguments are *named*, and positional arguments are not supported.\n\n    The `ArgumentParser` provides the method `parse_typed_args()` to parse\n    command line arguments and return an instance of its bound `pydantic`\n    model, populated with the parsed and validated user supplied command-line\n    arguments.\n    \"\"\"\n\n    # Argument Group Names\n    COMMANDS = \"commands\"\n    REQUIRED = \"required arguments\"\n    OPTIONAL = \"optional arguments\"\n    HELP = \"help\"\n\n    # Keyword Arguments\n    KWARG_REQUIRED = \"required\"\n\n    # Exit Codes\n    EXIT_ERROR = 2\n\n    def __init__(\n        self,\n        model: Type[PydanticModelT],\n        prog: Optional[str] = None,\n        description: Optional[str] = None,\n        version: Optional[str] = None,\n        epilog: Optional[str] = None,\n        add_help: bool = True,\n        exit_on_error: bool = True,\n    ) -&gt; None:\n        \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model.\n\n        Args:\n            model (Type[PydanticModelT]): Pydantic argument model class.\n            prog (Optional[str]): Program name for CLI.\n            description (Optional[str]): Program description for CLI.\n            version (Optional[str]): Program version string for CLI.\n            epilog (Optional[str]): Optional text following help message.\n            add_help (bool): Whether to add a `-h`/`--help` flag.\n            exit_on_error (bool): Whether to exit on error.\n        \"\"\"\n        # Initialise Super Class\n        if sys.version_info &lt; (3, 9):  # pragma: &lt;3.9 cover\n            super().__init__(\n                prog=prog,\n                description=description,\n                epilog=epilog,\n                add_help=False,  # Always disable the automatic help flag.\n                argument_default=argparse.SUPPRESS,  # Allow `pydantic` to handle defaults.\n            )\n\n        else:  # pragma: &gt;=3.9 cover\n            super().__init__(\n                prog=prog,\n                description=description,\n                epilog=epilog,\n                exit_on_error=exit_on_error,\n                add_help=False,  # Always disable the automatic help flag.\n                argument_default=argparse.SUPPRESS,  # Allow `pydantic` to handle defaults.\n            )\n\n        # Set Version, Add Help and Exit on Error Flag\n        self.version = version\n        self.add_help = add_help\n        self.exit_on_error = exit_on_error\n\n        # Add Arguments Groups\n        self._subcommands: Optional[argparse._SubParsersAction] = None\n        self._required_group = self.add_argument_group(ArgumentParser.REQUIRED)\n        self._optional_group = self.add_argument_group(ArgumentParser.OPTIONAL)\n        self._help_group = self.add_argument_group(ArgumentParser.HELP)\n\n        # Add Help and Version Flags\n        if self.add_help:\n            self._add_help_flag()\n        if self.version:\n            self._add_version_flag()\n\n        # Add Arguments from Model\n        self.model = self._add_model(model)\n\n    def parse_typed_args(\n        self,\n        args: Optional[List[str]] = None,\n    ) -&gt; PydanticModelT:\n        \"\"\"Parses command line arguments.\n\n        If `args` are not supplied by the user, then they are automatically\n        retrieved from the `sys.argv` command-line arguments.\n\n        Args:\n            args (Optional[List[str]]): Optional list of arguments to parse.\n\n        Returns:\n            PydanticModelT: Populated instance of typed arguments model.\n\n        Raises:\n            argparse.ArgumentError: Raised upon error, if not exiting on error.\n            SystemExit: Raised upon error, if exiting on error.\n        \"\"\"\n        # Call Super Class Method\n        namespace = self.parse_args(args)\n\n        # Convert Namespace to Dictionary\n        arguments = utils.namespaces.to_dict(namespace)\n\n        # Handle Possible Validation Errors\n        try:\n            # Convert Namespace to Pydantic Model\n            model = self.model.parse_obj(arguments)\n\n        except (pydantic.ValidationError, pydantic.env_settings.SettingsError) as exc:\n            # Catch exceptions, and use the ArgumentParser.error() method\n            # to report it to the user\n            self.error(utils.errors.format(exc))\n\n        # Return\n        return model\n\n    def add_argument(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; argparse.Action:\n        \"\"\"Adds an argument to the ArgumentParser.\n\n        Args:\n            *args (Any): Positional args to be passed to super class method.\n            **kwargs (Any): Keyword args to be passed to super class method.\n\n        Returns:\n            argparse.Action: Action generated by the argument.\n        \"\"\"\n        # Check whether the argument is required or optional\n        # We intercept the keyword arguments and \"pop\" here so that the\n        # `required` kwarg can never be passed through to the parent\n        # `ArgumentParser`, allowing Pydantic to perform all of the validation\n        # and error handling itself.\n        if kwargs.pop(ArgumentParser.KWARG_REQUIRED):\n            # Required\n            group = self._required_group\n\n        else:\n            # Optional\n            group = self._optional_group\n\n        # Return Action\n        return group.add_argument(*args, **kwargs)\n\n    def error(self, message: str) -&gt; NoReturn:\n        \"\"\"Prints a usage message to `stderr` and exits if required.\n\n        Args:\n            message (str): Message to print to the user.\n\n        Raises:\n            argparse.ArgumentError: Raised if not exiting on error.\n            SystemExit: Raised if exiting on error.\n        \"\"\"\n        # Print usage message\n        self.print_usage(sys.stderr)\n\n        # Check whether parser should exit\n        if self.exit_on_error:\n            self.exit(ArgumentParser.EXIT_ERROR, f\"{self.prog}: error: {message}\\n\")\n\n        # Raise Error\n        raise argparse.ArgumentError(None, f\"{self.prog}: error: {message}\")\n\n    def _commands(self) -&gt; argparse._SubParsersAction:\n        \"\"\"Creates and Retrieves Subcommands Action for the ArgumentParser.\n\n        Returns:\n            argparse._SubParsersAction: SubParsersAction for the subcommands.\n        \"\"\"\n        # Check for Existing Sub-Commands Group\n        if not self._subcommands:\n            # Add Sub-Commands Group\n            self._subcommands = self.add_subparsers(\n                title=ArgumentParser.COMMANDS,\n                action=actions.SubParsersAction,\n                required=True,\n            )\n\n            # Shuffle Group to the Top for Help Message\n            self._action_groups.insert(0, self._action_groups.pop())\n\n        # Return\n        return self._subcommands\n\n    def _add_help_flag(self) -&gt; None:\n        \"\"\"Adds help flag to argparser.\"\"\"\n        # Add help flag\n        self._help_group.add_argument(\n            \"-h\",\n            \"--help\",\n            action=argparse._HelpAction,\n            help=\"show this help message and exit\",\n        )\n\n    def _add_version_flag(self) -&gt; None:\n        \"\"\"Adds version flag to argparser.\"\"\"\n        # Add version flag\n        self._help_group.add_argument(\n            \"-v\",\n            \"--version\",\n            action=argparse._VersionAction,\n            help=\"show program's version number and exit\",\n        )\n\n    def _add_model(self, model: Type[PydanticModelT]) -&gt; Type[PydanticModelT]:\n        \"\"\"Adds the `pydantic` model to the argument parser.\n\n        This method also generates \"validators\" for the arguments derived from\n        the `pydantic` model, and generates a new subclass from the model\n        containing these validators.\n\n        Args:\n            model (Type[PydanticModelT]): Pydantic model class to add to the\n                argument parser.\n\n        Returns:\n            Type[PydanticModelT]: Pydantic model possibly with new validators.\n        \"\"\"\n        # Initialise validators dictionary\n        validators: Dict[str, utils.pydantic.PydanticValidator] = {}\n\n        # Loop through fields in model\n        for field in model.__fields__.values():\n            # Add field\n            validator = self._add_field(field)\n\n            # Update validators\n            utils.pydantic.update_validators(validators, validator)\n\n        # Construct and return model with validators\n        return utils.pydantic.model_with_validators(model, validators)\n\n    def _add_field(self, field: pydantic.fields.ModelField) -&gt; Optional[utils.pydantic.PydanticValidator]:\n        \"\"\"Adds `pydantic` field to argument parser.\n\n        Args:\n            field (pydantic.fields.ModelField): Field to be added to parser.\n\n        Returns:\n            Optional[utils.pydantic.PydanticValidator]: Possible validator.\n        \"\"\"\n        # Switch on Field Type\n        if parsers.command.should_parse(field):\n            # Add Command\n            validator = parsers.command.parse_field(self._commands(), field)\n\n        elif parsers.boolean.should_parse(field):\n            # Add Boolean Field\n            validator = parsers.boolean.parse_field(self, field)\n\n        elif parsers.container.should_parse(field):\n            # Add Container Field\n            validator = parsers.container.parse_field(self, field)\n\n        elif parsers.mapping.should_parse(field):\n            # Add Mapping Field\n            validator = parsers.mapping.parse_field(self, field)\n\n        elif parsers.literal.should_parse(field):\n            # Add Literal Field\n            validator = parsers.literal.parse_field(self, field)\n\n        elif parsers.enum.should_parse(field):\n            # Add Enum Field\n            validator = parsers.enum.parse_field(self, field)\n\n        else:\n            # Add Standard Field\n            validator = parsers.standard.parse_field(self, field)\n\n        # Return Validator\n        return validator\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.__init__","title":"<code>__init__(self, model, prog=None, description=None, version=None, epilog=None, add_help=True, exit_on_error=True)</code>  <code>special</code>","text":"<p>Instantiates the Typed Argument Parser with its <code>pydantic</code> model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[PydanticModelT]</code> <p>Pydantic argument model class.</p> required <code>prog</code> <code>Optional[str]</code> <p>Program name for CLI.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Program description for CLI.</p> <code>None</code> <code>version</code> <code>Optional[str]</code> <p>Program version string for CLI.</p> <code>None</code> <code>epilog</code> <code>Optional[str]</code> <p>Optional text following help message.</p> <code>None</code> <code>add_help</code> <code>bool</code> <p>Whether to add a <code>-h</code>/<code>--help</code> flag.</p> <code>True</code> <code>exit_on_error</code> <code>bool</code> <p>Whether to exit on error.</p> <code>True</code> Source code in <code>pydantic_argparse/argparse/parser.py</code> <pre><code>def __init__(\n    self,\n    model: Type[PydanticModelT],\n    prog: Optional[str] = None,\n    description: Optional[str] = None,\n    version: Optional[str] = None,\n    epilog: Optional[str] = None,\n    add_help: bool = True,\n    exit_on_error: bool = True,\n) -&gt; None:\n    \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model.\n\n    Args:\n        model (Type[PydanticModelT]): Pydantic argument model class.\n        prog (Optional[str]): Program name for CLI.\n        description (Optional[str]): Program description for CLI.\n        version (Optional[str]): Program version string for CLI.\n        epilog (Optional[str]): Optional text following help message.\n        add_help (bool): Whether to add a `-h`/`--help` flag.\n        exit_on_error (bool): Whether to exit on error.\n    \"\"\"\n    # Initialise Super Class\n    if sys.version_info &lt; (3, 9):  # pragma: &lt;3.9 cover\n        super().__init__(\n            prog=prog,\n            description=description,\n            epilog=epilog,\n            add_help=False,  # Always disable the automatic help flag.\n            argument_default=argparse.SUPPRESS,  # Allow `pydantic` to handle defaults.\n        )\n\n    else:  # pragma: &gt;=3.9 cover\n        super().__init__(\n            prog=prog,\n            description=description,\n            epilog=epilog,\n            exit_on_error=exit_on_error,\n            add_help=False,  # Always disable the automatic help flag.\n            argument_default=argparse.SUPPRESS,  # Allow `pydantic` to handle defaults.\n        )\n\n    # Set Version, Add Help and Exit on Error Flag\n    self.version = version\n    self.add_help = add_help\n    self.exit_on_error = exit_on_error\n\n    # Add Arguments Groups\n    self._subcommands: Optional[argparse._SubParsersAction] = None\n    self._required_group = self.add_argument_group(ArgumentParser.REQUIRED)\n    self._optional_group = self.add_argument_group(ArgumentParser.OPTIONAL)\n    self._help_group = self.add_argument_group(ArgumentParser.HELP)\n\n    # Add Help and Version Flags\n    if self.add_help:\n        self._add_help_flag()\n    if self.version:\n        self._add_version_flag()\n\n    # Add Arguments from Model\n    self.model = self._add_model(model)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.parse_typed_args","title":"<code>parse_typed_args(self, args=None)</code>","text":"<p>Parses command line arguments.</p> <p>If <code>args</code> are not supplied by the user, then they are automatically retrieved from the <code>sys.argv</code> command-line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Optional[List[str]]</code> <p>Optional list of arguments to parse.</p> <code>None</code> <p>Returns:</p> Type Description <code>PydanticModelT</code> <p>Populated instance of typed arguments model.</p> <p>Exceptions:</p> Type Description <code>argparse.ArgumentError</code> <p>Raised upon error, if not exiting on error.</p> <code>SystemExit</code> <p>Raised upon error, if exiting on error.</p> Source code in <code>pydantic_argparse/argparse/parser.py</code> <pre><code>def parse_typed_args(\n    self,\n    args: Optional[List[str]] = None,\n) -&gt; PydanticModelT:\n    \"\"\"Parses command line arguments.\n\n    If `args` are not supplied by the user, then they are automatically\n    retrieved from the `sys.argv` command-line arguments.\n\n    Args:\n        args (Optional[List[str]]): Optional list of arguments to parse.\n\n    Returns:\n        PydanticModelT: Populated instance of typed arguments model.\n\n    Raises:\n        argparse.ArgumentError: Raised upon error, if not exiting on error.\n        SystemExit: Raised upon error, if exiting on error.\n    \"\"\"\n    # Call Super Class Method\n    namespace = self.parse_args(args)\n\n    # Convert Namespace to Dictionary\n    arguments = utils.namespaces.to_dict(namespace)\n\n    # Handle Possible Validation Errors\n    try:\n        # Convert Namespace to Pydantic Model\n        model = self.model.parse_obj(arguments)\n\n    except (pydantic.ValidationError, pydantic.env_settings.SettingsError) as exc:\n        # Catch exceptions, and use the ArgumentParser.error() method\n        # to report it to the user\n        self.error(utils.errors.format(exc))\n\n    # Return\n    return model\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.add_argument","title":"<code>add_argument(self, *args, **kwargs)</code>","text":"<p>Adds an argument to the ArgumentParser.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional args to be passed to super class method.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword args to be passed to super class method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>argparse.Action</code> <p>Action generated by the argument.</p> Source code in <code>pydantic_argparse/argparse/parser.py</code> <pre><code>def add_argument(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; argparse.Action:\n    \"\"\"Adds an argument to the ArgumentParser.\n\n    Args:\n        *args (Any): Positional args to be passed to super class method.\n        **kwargs (Any): Keyword args to be passed to super class method.\n\n    Returns:\n        argparse.Action: Action generated by the argument.\n    \"\"\"\n    # Check whether the argument is required or optional\n    # We intercept the keyword arguments and \"pop\" here so that the\n    # `required` kwarg can never be passed through to the parent\n    # `ArgumentParser`, allowing Pydantic to perform all of the validation\n    # and error handling itself.\n    if kwargs.pop(ArgumentParser.KWARG_REQUIRED):\n        # Required\n        group = self._required_group\n\n    else:\n        # Optional\n        group = self._optional_group\n\n    # Return Action\n    return group.add_argument(*args, **kwargs)\n</code></pre>"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.error","title":"<code>error(self, message)</code>","text":"<p>Prints a usage message to <code>stderr</code> and exits if required.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to print to the user.</p> required <p>Exceptions:</p> Type Description <code>argparse.ArgumentError</code> <p>Raised if not exiting on error.</p> <code>SystemExit</code> <p>Raised if exiting on error.</p> Source code in <code>pydantic_argparse/argparse/parser.py</code> <pre><code>def error(self, message: str) -&gt; NoReturn:\n    \"\"\"Prints a usage message to `stderr` and exits if required.\n\n    Args:\n        message (str): Message to print to the user.\n\n    Raises:\n        argparse.ArgumentError: Raised if not exiting on error.\n        SystemExit: Raised if exiting on error.\n    \"\"\"\n    # Print usage message\n    self.print_usage(sys.stderr)\n\n    # Check whether parser should exit\n    if self.exit_on_error:\n        self.exit(ArgumentParser.EXIT_ERROR, f\"{self.prog}: error: {message}\\n\")\n\n    # Raise Error\n    raise argparse.ArgumentError(None, f\"{self.prog}: error: {message}\")\n</code></pre>"},{"location":"reference/pydantic_argparse/compatibility/","title":"compatibility","text":""},{"location":"reference/pydantic_argparse/compatibility/#__init__py","title":"__init__.py","text":"<p>Compatibiltity Shims for Declarative Typed Argument Parsing.</p> <p>This package contains compatibility shims for the <code>pydantic</code> and <code>argparse</code> modules, so that we can properly maintain version compatibility in one place.</p> <p>The public interface exposed by this package is the module shims themselves.</p>"},{"location":"reference/pydantic_argparse/compatibility/argparse/","title":"argparse","text":"<p>Compatibility Shim for ArgumentParser.</p> <p>In order to support Python 3.8 while retaining the unit tests, we need to backport the bugfix for <code>BPO-29298</code>.</p>"},{"location":"reference/pydantic_argparse/compatibility/pydantic/","title":"pydantic","text":"<p>Compatibility Shim for Pydantic.</p> <p>In order to support both Pydantic v1 and Pydantic v2, we need to make sure we import the module correctly:</p> <ul> <li>For <code>pydantic~=2.0</code> there is a working <code>v1</code> module.</li> <li>For <code>pydantic==1.10.15</code> there is a broken <code>v1</code> module (with no <code>fields</code>).</li> <li>For <code>pydantic&lt;1.10.14</code> there is no <code>v1</code> module.</li> </ul>"},{"location":"reference/pydantic_argparse/parsers/","title":"parsers","text":""},{"location":"reference/pydantic_argparse/parsers/#__init__py","title":"__init__.py","text":"<p>Parses Pydantic Fields to Command-Line Arguments.</p> <p>This package contains the functions required for parsing <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p> <p>The public interface exposed by this package is the <code>parsing</code> modules, which each contain the <code>should_parse()</code> and <code>parse_field()</code> functions.</p>"},{"location":"reference/pydantic_argparse/parsers/boolean/","title":"boolean","text":"<p>Parses Boolean Pydantic Fields to Command-Line Arguments.</p> <p>The <code>boolean</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses boolean <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p>"},{"location":"reference/pydantic_argparse/parsers/boolean/#pydantic_argparse.parsers.boolean.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as a <code>boolean</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as a <code>boolean</code>.</p> Source code in <code>pydantic_argparse/parsers/boolean.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as a `boolean`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as a `boolean`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, bool)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/boolean/#pydantic_argparse.parsers.boolean.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds boolean pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/boolean.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds boolean pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Compute Argument Intrinsics\n    is_inverted = not field.required and bool(field.get_default())\n\n    # Determine Argument Properties\n    action = (\n        actions.BooleanOptionalAction\n        if field.required\n        else argparse._StoreFalseAction\n        if is_inverted\n        else argparse._StoreTrueAction\n    )\n\n    # Add Boolean Field\n    parser.add_argument(\n        utils.arguments.name(field, is_inverted),\n        action=action,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        required=bool(field.required),\n    )\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: v)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/command/","title":"command","text":"<p>Parses Nested Pydantic Model Fields to Sub-Commands.</p> <p>The <code>command</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses nested <code>pydantic</code> model fields to <code>ArgumentParser</code> sub-commands.</p>"},{"location":"reference/pydantic_argparse/parsers/command/#pydantic_argparse.parsers.command.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as a <code>command</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as a <code>command</code>.</p> Source code in <code>pydantic_argparse/parsers/command.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as a `command`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as a `command`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, pydantic.BaseModel)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/command/#pydantic_argparse.parsers.command.parse_field","title":"<code>parse_field(subparser, field)</code>","text":"<p>Adds command pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>subparser</code> <code>argparse._SubParsersAction</code> <p>Sub-parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/command.py</code> <pre><code>def parse_field(\n    subparser: argparse._SubParsersAction,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds command pydantic field to argument parser.\n\n    Args:\n        subparser (argparse._SubParsersAction): Sub-parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Add Command\n    subparser.add_parser(\n        field.alias,\n        help=field.field_info.description,\n        model=field.outer_type_,  # type: ignore[call-arg]\n        exit_on_error=False,  # Allow top level parser to handle exiting\n    )\n\n    # Return\n    return None\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/container/","title":"container","text":"<p>Parses Container Pydantic Fields to Command-Line Arguments.</p> <p>The <code>container</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses container <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p>"},{"location":"reference/pydantic_argparse/parsers/container/#pydantic_argparse.parsers.container.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as a <code>container</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as a <code>container</code>.</p> Source code in <code>pydantic_argparse/parsers/container.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as a `container`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as a `container`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, collections.abc.Container) and not utils.types.is_field_a(\n        field, (collections.abc.Mapping, enum.Enum, str, bytes)\n    )\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/container/#pydantic_argparse.parsers.container.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds container pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/container.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds container pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Add Container Field\n    parser.add_argument(\n        utils.arguments.name(field),\n        action=argparse._StoreAction,\n        nargs=argparse.ONE_OR_MORE,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        metavar=field.alias.upper(),\n        required=bool(field.required),\n    )\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: v)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/enum/","title":"enum","text":"<p>Parses Enum Pydantic Fields to Command-Line Arguments.</p> <p>The <code>enum</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses enum <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p>"},{"location":"reference/pydantic_argparse/parsers/enum/#pydantic_argparse.parsers.enum.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as an <code>enum</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as an <code>enum</code>.</p> Source code in <code>pydantic_argparse/parsers/enum.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as an `enum`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as an `enum`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, enum.Enum)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/enum/#pydantic_argparse.parsers.enum.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds enum pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/enum.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds enum pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Extract Enum\n    enum_type: Type[enum.Enum] = field.outer_type_\n\n    # Compute Argument Intrinsics\n    is_flag = len(enum_type) == 1 and not bool(field.required)\n    is_inverted = is_flag and field.get_default() is not None and field.allow_none\n\n    # Determine Argument Properties\n    metavar = f\"{{{', '.join(e.name for e in enum_type)}}}\"\n    action = argparse._StoreConstAction if is_flag else argparse._StoreAction\n    const = {} if not is_flag else {\"const\": None} if is_inverted else {\"const\": next(iter(enum_type))}  # type: ignore\n\n    # Add Enum Field\n    parser.add_argument(\n        utils.arguments.name(field, is_inverted),\n        action=action,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        metavar=metavar,\n        required=bool(field.required),\n        **const,  # type: ignore[arg-type]\n    )\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: enum_type[v])\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/literal/","title":"literal","text":"<p>Parses Literal Pydantic Fields to Command-Line Arguments.</p> <p>The <code>literal</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses literal <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p>"},{"location":"reference/pydantic_argparse/parsers/literal/#pydantic_argparse.parsers.literal.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as a <code>literal</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as a <code>literal</code>.</p> Source code in <code>pydantic_argparse/parsers/literal.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as a `literal`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as a `literal`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, Literal)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/literal/#pydantic_argparse.parsers.literal.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds enum pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/literal.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds enum pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Extract Choices\n    choices = get_args(field.outer_type_)\n\n    # Compute Argument Intrinsics\n    is_flag = len(choices) == 1 and not bool(field.required)\n    is_inverted = is_flag and field.get_default() is not None and field.allow_none\n\n    # Determine Argument Properties\n    metavar = f\"{{{', '.join(str(c) for c in choices)}}}\"\n    action = argparse._StoreConstAction if is_flag else argparse._StoreAction\n    const = {} if not is_flag else {\"const\": None} if is_inverted else {\"const\": choices[0]}\n\n    # Add Literal Field\n    parser.add_argument(\n        utils.arguments.name(field, is_inverted),\n        action=action,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        metavar=metavar,\n        required=bool(field.required),\n        **const,  # type: ignore[arg-type]\n    )\n\n    # Construct String Representation Mapping of Choices\n    # This allows us O(1) parsing of choices from strings\n    mapping = {str(choice): choice for choice in choices}\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: mapping[v])\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/mapping/","title":"mapping","text":"<p>Parses Mapping Pydantic Fields to Command-Line Arguments.</p> <p>The <code>mapping</code> module contains the <code>should_parse</code> function, which checks whether this module should be used to parse the field, as well as the <code>parse_field</code> function, which parses mapping <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p>"},{"location":"reference/pydantic_argparse/parsers/mapping/#pydantic_argparse.parsers.mapping.should_parse","title":"<code>should_parse(field)</code>","text":"<p>Checks whether the field should be parsed as a <code>mapping</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field should be parsed as a <code>mapping</code>.</p> Source code in <code>pydantic_argparse/parsers/mapping.py</code> <pre><code>def should_parse(field: pydantic.fields.ModelField) -&gt; bool:\n    \"\"\"Checks whether the field should be parsed as a `mapping`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to check.\n\n    Returns:\n        bool: Whether the field should be parsed as a `mapping`.\n    \"\"\"\n    # Check and Return\n    return utils.types.is_field_a(field, collections.abc.Mapping)\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/mapping/#pydantic_argparse.parsers.mapping.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds mapping pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/mapping.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds mapping pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Add Mapping Field\n    parser.add_argument(\n        utils.arguments.name(field),\n        action=argparse._StoreAction,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        metavar=field.alias.upper(),\n        required=bool(field.required),\n    )\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: ast.literal_eval(v))\n</code></pre>"},{"location":"reference/pydantic_argparse/parsers/standard/","title":"standard","text":"<p>Parses Standard Pydantic Fields to Command-Line Arguments.</p> <p>The <code>standard</code> module contains the <code>parse_field</code> function, which parses standard <code>pydantic</code> model fields to <code>ArgumentParser</code> command-line arguments.</p> <p>Unlike the other <code>parser</code> modules, the <code>standard</code> module does not contain a <code>should_parse</code> function. This is because it is the fallback case, where fields that do not match any other types and require no special handling are parsed.</p>"},{"location":"reference/pydantic_argparse/parsers/standard/#pydantic_argparse.parsers.standard.parse_field","title":"<code>parse_field(parser, field)</code>","text":"<p>Adds standard pydantic field to argument parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>Argument parser to add to.</p> required <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to be added to parser.</p> required <p>Returns:</p> Type Description <code>Optional[utils.pydantic.PydanticValidator]</code> <p>Possible validator method.</p> Source code in <code>pydantic_argparse/parsers/standard.py</code> <pre><code>def parse_field(\n    parser: argparse.ArgumentParser,\n    field: pydantic.fields.ModelField,\n) -&gt; Optional[utils.pydantic.PydanticValidator]:\n    \"\"\"Adds standard pydantic field to argument parser.\n\n    Args:\n        parser (argparse.ArgumentParser): Argument parser to add to.\n        field (pydantic.fields.ModelField): Field to be added to parser.\n\n    Returns:\n        Optional[utils.pydantic.PydanticValidator]: Possible validator method.\n    \"\"\"\n    # Add Standard Field\n    parser.add_argument(\n        utils.arguments.name(field),\n        action=argparse._StoreAction,\n        help=utils.arguments.description(field),\n        dest=field.alias,\n        metavar=field.alias.upper(),\n        required=bool(field.required),\n    )\n\n    # Construct and Return Validator\n    return utils.pydantic.as_validator(field, lambda v: v)\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/","title":"utils","text":""},{"location":"reference/pydantic_argparse/utils/#__init__py","title":"__init__.py","text":"<p>Utilities for Declarative Typed Argument Parsing.</p> <p>This package contains helper utility functions for the typed argument parsing process, including formatting argument names and descriptions, formatting errors, recursively parsing <code>argparse.Namespace</code> objects to <code>dict</code>s, interacting with the internals of <code>pydantic</code> and determining the types of <code>pydantic</code> fields.</p> <p>The public interface exposed by this package is the various described utility modules each containing helper functions.</p>"},{"location":"reference/pydantic_argparse/utils/arguments/","title":"arguments","text":"<p>Arguments Utility Functions for Declarative Typed Argument Parsing.</p> <p>The <code>arguments</code> module contains utility functions used for formatting argument names and formatting argument descriptions.</p>"},{"location":"reference/pydantic_argparse/utils/arguments/#pydantic_argparse.utils.arguments.name","title":"<code>name(field, invert=False)</code>","text":"<p>Standardises argument name.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to construct name for.</p> required <code>invert</code> <code>bool</code> <p>Whether to invert the name by prepending <code>--no-</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Standardised name of the argument.</p> Source code in <code>pydantic_argparse/utils/arguments.py</code> <pre><code>def name(field: pydantic.fields.ModelField, invert: bool = False) -&gt; str:\n    \"\"\"Standardises argument name.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to construct name for.\n        invert (bool): Whether to invert the name by prepending `--no-`.\n\n    Returns:\n        str: Standardised name of the argument.\n    \"\"\"\n    # Construct Prefix\n    prefix = \"--no-\" if invert else \"--\"\n\n    # Prepend prefix, replace '_' with '-'\n    return f\"{prefix}{field.alias.replace('_', '-')}\"\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/arguments/#pydantic_argparse.utils.arguments.description","title":"<code>description(field)</code>","text":"<p>Standardises argument description.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to construct description for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Standardised description of the argument.</p> Source code in <code>pydantic_argparse/utils/arguments.py</code> <pre><code>def description(field: pydantic.fields.ModelField) -&gt; str:\n    \"\"\"Standardises argument description.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to construct description for.\n\n    Returns:\n        str: Standardised description of the argument.\n    \"\"\"\n    # Construct Default String\n    default = f\"(default: {field.get_default()})\" if not field.required else None\n\n    # Return Standardised Description String\n    return \" \".join(filter(None, [field.field_info.description, default]))\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/errors/","title":"errors","text":"<p>Errors Utility Functions for Declarative Typed Argument Parsing.</p> <p>The <code>errors</code> module contains a utility function used for formatting <code>pydantic</code> Validation Errors to human readable messages.</p>"},{"location":"reference/pydantic_argparse/utils/errors/#pydantic_argparse.utils.errors.format","title":"<code>format(error)</code>","text":"<p>Formats a <code>pydantic</code> error into a human readable format.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>PydanticError</code> <p><code>pydantic</code> error to be formatted.</p> required <p>Returns:</p> Type Description <code>str</code> <p><code>pydantic</code> error in a human readable format.</p> Source code in <code>pydantic_argparse/utils/errors.py</code> <pre><code>def format(error: PydanticError) -&gt; str:  # noqa: A001\n    \"\"\"Formats a `pydantic` error into a human readable format.\n\n    Args:\n        error (PydanticError): `pydantic` error to be formatted.\n\n    Returns:\n        str: `pydantic` error in a human readable format.\n    \"\"\"\n    # Format and Return\n    return str(error)\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/namespaces/","title":"namespaces","text":"<p>Namespaces Utility Functions for Declarative Typed Argument Parsing.</p> <p>The <code>namespaces</code> module contains a utility function used for recursively converting <code>argparse.Namespace</code>s to regular Python <code>dict</code>s.</p>"},{"location":"reference/pydantic_argparse/utils/namespaces/#pydantic_argparse.utils.namespaces.to_dict","title":"<code>to_dict(namespace)</code>","text":"<p>Converts a nested namespace to a dictionary recursively.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>argparse.Namespace</code> <p>Namespace object to convert.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Nested dictionary generated from namespace.</p> Source code in <code>pydantic_argparse/utils/namespaces.py</code> <pre><code>def to_dict(namespace: argparse.Namespace) -&gt; Dict[str, Any]:\n    \"\"\"Converts a nested namespace to a dictionary recursively.\n\n    Args:\n        namespace (argparse.Namespace): Namespace object to convert.\n\n    Returns:\n        Dict[str, Any]: Nested dictionary generated from namespace.\n    \"\"\"\n    # Get Dictionary from Namespace Vars\n    dictionary = vars(namespace)\n\n    # Loop Through Dictionary\n    for key, value in dictionary.items():\n        # Check for Namespace Objects\n        if isinstance(value, argparse.Namespace):\n            # Recurse\n            dictionary[key] = to_dict(value)\n\n    # Return\n    return dictionary\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/pydantic/","title":"pydantic","text":"<p>Pydantic Utility Functions for Declarative Typed Argument Parsing.</p> <p>The <code>pydantic</code> module contains utility functions used for interacting with the internals of <code>pydantic</code>, such as constructing field validators, updating field validator dictionaries and constructing new model classes with dynamically generated validators and environment variable parsers.</p>"},{"location":"reference/pydantic_argparse/utils/pydantic/#pydantic_argparse.utils.pydantic.as_validator","title":"<code>as_validator(field, caster)</code>","text":"<p>Shortcut to wrap a caster and construct a validator for a given field.</p> <p>The provided caster function must cast from a string to the type required by the field. Once wrapped, the constructed validator will pass through any non-string values, or any values that cause the caster function to raise an exception to let the built-in <code>pydantic</code> field validation handle them. The validator will also cast empty strings to <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Field to construct validator for.</p> required <code>caster</code> <code>Callable[[str], Any]</code> <p>String to field type caster function.</p> required <p>Returns:</p> Type Description <code>PydanticValidator</code> <p>Constructed field validator function.</p> Source code in <code>pydantic_argparse/utils/pydantic.py</code> <pre><code>def as_validator(\n    field: pydantic.fields.ModelField,\n    caster: Callable[[str], Any],\n) -&gt; PydanticValidator:\n    \"\"\"Shortcut to wrap a caster and construct a validator for a given field.\n\n    The provided caster function must cast from a string to the type required\n    by the field. Once wrapped, the constructed validator will pass through any\n    non-string values, or any values that cause the caster function to raise an\n    exception to let the built-in `pydantic` field validation handle them. The\n    validator will also cast empty strings to `None`.\n\n    Args:\n        field (pydantic.fields.ModelField): Field to construct validator for.\n        caster (Callable[[str], Any]): String to field type caster function.\n\n    Returns:\n        PydanticValidator: Constructed field validator function.\n    \"\"\"\n\n    # Dynamically construct a `pydantic` validator function for the supplied\n    # field. The constructed validator must be `pre=True` so that the validator\n    # is called before the built-in `pydantic` field validation occurs and is\n    # provided with the raw input data. The constructed validator must also be\n    # `allow_reuse=True` so the `__validator` function name can be reused\n    # multiple times when being decorated as a `pydantic` validator. Note that\n    # despite the `__validator` function *name* being reused, each instance of\n    # the validator function is uniquely constructed for the supplied field.\n    @pydantic.validator(field.name, pre=True, allow_reuse=True)\n    def __validator(cls: Type[Any], value: T) -&gt; Union[T, None, Any]:\n        if not isinstance(value, str):\n            return value\n        if not value:\n            return None\n        try:\n            return caster(value)\n        except Exception:\n            return value\n\n    # Rename the validator uniquely for this field to avoid any collisions. The\n    # leading `__` and prefix of `pydantic_argparse` should guard against any\n    # potential collisions with user defined validators.\n    __validator.__name__ = f\"__pydantic_argparse_{field.name}\"\n\n    # Return the constructed validator\n    return __validator\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/pydantic/#pydantic_argparse.utils.pydantic.update_validators","title":"<code>update_validators(validators, validator)</code>","text":"<p>Updates a validators dictionary with a possible new field validator.</p> <p>Note that this function mutates the validators dictionary in-place, and does not return the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>validators</code> <code>Dict[str, PydanticValidator]</code> <p>Validators to update.</p> required <code>validator</code> <code>Optional[PydanticValidator]</code> <p>Possible field validator.</p> required Source code in <code>pydantic_argparse/utils/pydantic.py</code> <pre><code>def update_validators(\n    validators: Dict[str, PydanticValidator],\n    validator: Optional[PydanticValidator],\n) -&gt; None:\n    \"\"\"Updates a validators dictionary with a possible new field validator.\n\n    Note that this function mutates the validators dictionary *in-place*, and\n    does not return the dictionary.\n\n    Args:\n        validators (Dict[str, PydanticValidator]): Validators to update.\n        validator (Optional[PydanticValidator]): Possible field validator.\n    \"\"\"\n    # Check for Validator\n    if validator:\n        # Add Validator\n        validators[validator.__name__] = validator\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/pydantic/#pydantic_argparse.utils.pydantic.model_with_validators","title":"<code>model_with_validators(model, validators)</code>","text":"<p>Generates a new <code>pydantic</code> model class with the supplied validators.</p> <p>If the supplied base model is a subclass of <code>pydantic.BaseSettings</code>, then the newly generated model will also have a new <code>parse_env_var</code> classmethod monkeypatched onto it that suppresses any exceptions raised when initially parsing the environment variables. This allows the raw values to still be passed through to the <code>pydantic</code> field validators if initial parsing fails.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[PydanticModelT]</code> <p>Model type to use as base class.</p> required <code>validators</code> <code>Dict[str, PydanticValidator]</code> <p>Field validators to add.</p> required <p>Returns:</p> Type Description <code>Type[PydanticModelT]</code> <p>New <code>pydantic</code> model type with field validators.</p> Source code in <code>pydantic_argparse/utils/pydantic.py</code> <pre><code>def model_with_validators(\n    model: Type[PydanticModelT],\n    validators: Dict[str, PydanticValidator],\n) -&gt; Type[PydanticModelT]:\n    \"\"\"Generates a new `pydantic` model class with the supplied validators.\n\n    If the supplied base model is a subclass of `pydantic.BaseSettings`, then\n    the newly generated model will also have a new `parse_env_var` classmethod\n    monkeypatched onto it that suppresses any exceptions raised when initially\n    parsing the environment variables. This allows the raw values to still be\n    passed through to the `pydantic` field validators if initial parsing fails.\n\n    Args:\n        model (Type[PydanticModelT]): Model type to use as base class.\n        validators (Dict[str, PydanticValidator]): Field validators to add.\n\n    Returns:\n        Type[PydanticModelT]: New `pydantic` model type with field validators.\n    \"\"\"\n    # Construct New Model with Validators\n    model = pydantic.create_model(\n        model.__name__,\n        __base__=model,\n        __validators__=validators,\n    )\n\n    # Check if the model is a `BaseSettings`\n    if issubclass(model, pydantic.BaseSettings):\n        # Hold a reference to the current `parse_env_var` classmethod\n        parse_env_var = model.__config__.parse_env_var\n\n        # Construct a new `parse_env_var` function which suppresses exceptions\n        # raised by the current `parse_env_var` classmethod. This allows the\n        # raw values to be passed through to the `pydantic` field validator\n        # methods if they cannot be parsed initially.\n        def __parse_env_var(field_name: str, raw_val: str) -&gt; Any:\n            with contextlib.suppress(Exception):\n                return parse_env_var(field_name, raw_val)\n            return raw_val\n\n        # Monkeypatch `parse_env_var`\n        model.__config__.parse_env_var = __parse_env_var  # type: ignore[method-assign]\n\n    # Return Constructed Model\n    return model\n</code></pre>"},{"location":"reference/pydantic_argparse/utils/types/","title":"types","text":"<p>Types Utility Functions for Declarative Typed Argument Parsing.</p> <p>The <code>types</code> module contains a utility function used for determining and comparing the types of `pydantic fields.</p>"},{"location":"reference/pydantic_argparse/utils/types/#pydantic_argparse.utils.types.is_field_a","title":"<code>is_field_a(field, types)</code>","text":"<p>Checks whether the subject is any of the supplied types.</p> <p>The checks are performed as follows:</p> <ol> <li><code>field</code> is one of the <code>types</code></li> <li><code>field</code> is an instance of one of the <code>types</code></li> <li><code>field</code> is a subclass of one of the <code>types</code></li> </ol> <p>If any of these conditions are <code>True</code>, then the function returns <code>True</code>, else <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>pydantic.fields.ModelField</code> <p>Subject field to check type of.</p> required <code>types</code> <code>Union[Any, Tuple[Any, ...]]</code> <p>Type(s) to compare field against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the field is considered one of the types.</p> Source code in <code>pydantic_argparse/utils/types.py</code> <pre><code>def is_field_a(\n    field: pydantic.fields.ModelField,\n    types: Union[Any, Tuple[Any, ...]],\n) -&gt; bool:\n    \"\"\"Checks whether the subject *is* any of the supplied types.\n\n    The checks are performed as follows:\n\n    1. `field` *is* one of the `types`\n    2. `field` *is an instance* of one of the `types`\n    3. `field` *is a subclass* of one of the `types`\n\n    If any of these conditions are `True`, then the function returns `True`,\n    else `False`.\n\n    Args:\n        field (pydantic.fields.ModelField): Subject field to check type of.\n        types (Union[Any, Tuple[Any, ...]]): Type(s) to compare field against.\n\n    Returns:\n        bool: Whether the field *is* considered one of the types.\n    \"\"\"\n    # Create tuple if only one type was provided\n    if not isinstance(types, tuple):\n        types = (types,)\n\n    # Get field type, or origin if applicable\n    field_type = get_origin(field.outer_type_) or field.outer_type_\n\n    # Check `isinstance` and `issubclass` validity\n    # In order for `isinstance` and `issubclass` to be valid, all arguments\n    # should be instances of `type`, otherwise `TypeError` *may* be raised.\n    is_valid = all(isinstance(t, type) for t in (*types, field_type))\n\n    # Perform checks and return\n    return (\n        field_type in types\n        or (is_valid and isinstance(field_type, types))\n        or (is_valid and issubclass(field_type, types))\n    )\n</code></pre>"},{"location":"usage/argument_parser/","title":"Argument Parser","text":""},{"location":"usage/argument_parser/#overview","title":"Overview","text":"<p>The interface for <code>pydantic-argparse</code> is the custom typed <code>ArgumentParser</code> class, which provides declarative, typed argument parsing.</p> <p>This <code>ArgumentParser</code> class presents a very similar interface to the <code>python</code> standard library <code>argparse.ArgumentParser</code>, in an attempt to provide as close to a drop-in-replacement as possible.</p>"},{"location":"usage/argument_parser/#parser-instantiation","title":"Parser Instantiation","text":"<p>To create an instance of the <code>ArgumentParser</code>: <pre><code>parser = pydantic_argparse.ArgumentParser(\n    model=Arguments,\n    prog=\"Program Name\",\n    description=\"Program Description\",\n    version=\"1.2.3\",\n    epilog=\"Program Epilog\",\n    add_help=True,\n    exit_on_error=True,\n)\n</code></pre></p>"},{"location":"usage/argument_parser/#required-parameters","title":"Required Parameters","text":"<p>The required parameters for the <code>ArgumentParser</code> are outlined below:</p> <ul> <li><code>model</code> (<code>Type[pydantic.BaseModel]</code>):     The model that defines the command-line arguments</li> </ul>"},{"location":"usage/argument_parser/#optional-parameters","title":"Optional Parameters","text":"<p>The optional parameters for the <code>ArgumentParser</code> are outlined below:</p> <ul> <li><code>prog</code> (<code>Optional[str]</code>):     The program name that appears in the help message</li> <li><code>description</code> (<code>Optional[str]</code>):     The program description that appears in the help message</li> <li><code>version</code> (<code>Optional[str]</code>):     The program version that appears in the help message</li> <li><code>epilog</code> (<code>Optional[str]</code>):     The program epilog that appears in the help message</li> <li><code>add_help</code> (<code>bool</code>):     Whether to add the <code>-h / --help</code> help message action</li> <li><code>exit_on_error</code> (<code>bool</code>):     Whether to exit, or raise an <code>ArgumentError</code> upon an error</li> </ul>"},{"location":"usage/argument_parser/#argument-parsing","title":"Argument Parsing","text":"<p>To parse command-line arguments into the <code>model</code> using the <code>ArgumentParser</code>: <pre><code>args = parser.parse_typed_args()\n</code></pre></p> <p>Info</p> <p>The <code>ArgumentParser</code> is generic over its <code>pydantic</code> <code>model</code>. This means that the parsed <code>args</code> object is type-hinted as an instance of its <code>model</code>.</p>"},{"location":"usage/argument_parser/#optional-parameters_1","title":"Optional Parameters","text":"<p>The optional parameters for the <code>parse_typed_args</code> method are outlined below:</p> <ul> <li><code>args</code> (<code>Optional[List[str]]</code>):     Optional list of arguments to parse instead of <code>sys.argv</code></li> </ul>"},{"location":"usage/arguments/","title":"Arguments","text":""},{"location":"usage/arguments/#overview","title":"Overview","text":"<p>At the core of <code>pydantic-argparse</code> is the <code>pydantic</code> model, in which arguments are declared with <code>pydantic</code> fields. This combination of the model and its fields defines the schema for your command-line arguments.</p>"},{"location":"usage/arguments/#pydantic","title":"Pydantic","text":""},{"location":"usage/arguments/#models","title":"Models","text":"<p>A <code>pydantic</code> model is simply a dataclass-like class that inherits from the <code>pydantic.BaseModel</code> base class. In <code>pydantic-argparse</code>, this model is used to declaratively define your command-line arguments.</p> <pre><code>class Arguments(BaseModel):\n    # Required\n    string: str\n    integer: int\n    number: float\n\n    # Optional\n    boolean: bool = False\n</code></pre> <p>Arbitrary data, such as raw command-line arguments, can be passed to a model. After parsing and validation <code>pydantic</code> guarantees that the fields of the resultant model instance will conform to the field types defined on the model.</p> <p>Info</p> <p>For more information about <code>pydantic</code> models, see the <code>pydantic</code> docs.</p>"},{"location":"usage/arguments/#fields","title":"Fields","text":"<p>A <code>pydantic</code> model contains fields, which are the model class attributes. These fields define each <code>pydantic-argparse</code> command-line argument, and they can be declared either implicitly (as above), or explicitly (as below).</p> <pre><code>class Arguments(BaseModel):\n    # Required\n    string: str = Field(description=\"this argument is a string\")\n    integer: int = Field(description=\"this argument is an integer\")\n    number: float = Field(description=\"this argument is a number\")\n\n    # Optional\n    boolean: bool = Field(False, description=\"this argument is a boolean\")\n</code></pre> <p>Explicitly defining fields can provide extra information about an argument, either for the command-line interface, the model schema or features such as complex validation.</p> <p>Info</p> <p>For more information about <code>pydantic</code> fields, see the <code>pydantic</code> docs.</p>"},{"location":"usage/arguments/#arguments","title":"Arguments","text":""},{"location":"usage/arguments/#required","title":"Required","text":"<p>A field defines a required argument if it has no default value, or a default value of the <code>Ellipses</code> (<code>...</code>) singleton object.</p> <pre><code>class Arguments(BaseModel):\n    a: int\n    b: int = ...\n    c: int = Field()\n    d: int = Field(...)\n</code></pre>"},{"location":"usage/arguments/#optional","title":"Optional","text":"<p>A field defines an optional argument if it has a default value.</p> <pre><code>class Arguments(BaseModel):\n    a: int = 42\n    b: int = Field(42)\n</code></pre> <p>A field can also define an optional argument if it is type-hinted as <code>Optional</code>. This type-hinting also allows the value of <code>None</code> for the field.</p> <pre><code>class Arguments(BaseModel):\n    a: Optional[int]\n    b: Optional[int] = None\n    c: Optional[int] = Field()\n    d: Optional[int] = Field(None)\n</code></pre>"},{"location":"usage/arguments/#descriptions","title":"Descriptions","text":"<p>A field can be provided with a <code>description</code>, which will appear in the command-line interface help message.</p> <pre><code>class Arguments(BaseModel):\n    a: int = Field(description=\"this is the command-line description!\")\n</code></pre>"},{"location":"usage/arguments/#aliases","title":"Aliases","text":"<p>A field can be provided with an <code>alias</code>, which will change the argument name in the command-line interface.</p> <pre><code>class Arguments(BaseModel):\n    # We want our argument to be named `class` (i.e., `--class`), but `class`\n    # is a reserved keyword in Python. To accomplish this, we can use the Field\n    # `alias` to override the argument name.\n    class_argument: int = Field(alias=\"class\")\n</code></pre> <p>Tip</p> <p>This feature allows you to define arguments that use a reserved python keyword as the name. For example: <code>class</code>, <code>continue</code>, <code>async</code>.</p> <p>You can see the list of reserved keywords in Python at any time by typing <code>help(\"keywords\")</code> into the Python interpreter.</p>"},{"location":"usage/arguments/#environment-variables","title":"Environment Variables","text":"<p>Functionality to parse both required and optional arguments from environment variables is provided via the <code>pydantic.BaseSettings</code> base class.</p> <p>Simply inherit from <code>pydantic.BaseSettings</code> instead of <code>pydantic.BaseModel</code>:</p> <pre><code>class Arguments(BaseSettings):\n    integer: int\n</code></pre> <p>Arguments can then be provided via environment variables:</p> <pre><code>$ export INTEGER=123\n$ python3 example.py\nArguments(integer=123)\n\n$ INTEGER=456 python3 example.py\nArguments(integer=456)\n</code></pre> <p>Arguments supplied via the command-line take precedence over environment variables:</p> <pre><code>$ export INTEGER=123\n$ python3 example.py --integer 42\nArguments(integer=42)\n\n$ INTEGER=456 python3 example.py --integer 42\nArguments(integer=42)\n</code></pre>"},{"location":"usage/arguments/#validation","title":"Validation","text":"<p>When parsing command-line arguments with <code>parser.parse_typed_args()</code>, the raw values are parsed and validated using <code>pydantic</code>. The parser has different behaviours depending on whether the supplied command-line arguments are valid.</p> <p>Consider the following example model:</p> <pre><code>class Arguments(BaseModel):\n    integer: int\n</code></pre>"},{"location":"usage/arguments/#success","title":"Success","text":"<p>When the provided command-line arguments satisfy the <code>pydantic</code> model, a populated instance of the model is returned</p> <pre><code>$ python3 example.py --integer 42\nArguments(integer=42)\n</code></pre>"},{"location":"usage/arguments/#failure","title":"Failure","text":"<p>When the provided command-line arguments do not satisfy the <code>pydantic</code> model, the <code>ArgumentParser</code> will provide an error to the user. For example:</p> <pre><code>$ python3 example.py\nusage: example.py [-h] --integer INTEGER\nexample.py: error: 1 validation error for Arguments\ninteger\n  field required (type=value_error.missing)\n\n$ python3 example.py --integer hello\nusage: example.py [-h] --integer INTEGER\nexample.py: error: 1 validation error for Arguments\ninteger\n  value is not a valid integer (type=type_error.integer)\n</code></pre> <p>Note</p> <p>The validation error shown to the user is the same as the error that <code>pydantic</code> provides with its <code>pydantic.ValidationError</code>.</p>"},{"location":"usage/arguments/#under-the-hood","title":"Under the Hood","text":"<p>Under the hood <code>pydantic-argparse</code> dynamically generates extra custom <code>@pydantic.validator</code> class methods for each of your argument fields.</p> <p>These validators behave slightly differently for each argument type, but in general they:</p> <ul> <li>Parse empty <code>str</code> values to <code>None</code>.</li> <li>Parse choices (i.e., <code>Enum</code>s or <code>Literal</code>s) from <code>str</code>s to their respective   types (if applicable).</li> <li>Otherwise, pass values through unchanged.</li> </ul> <p>The validators are constructed with the <code>pre=True</code> argument, ensuring that they are called before any of the user's <code>@pydantic.validator</code> class methods and the built-in <code>pydantic</code> field validation. This means they are provided with the most raw input data possible.</p> <p>After the generated validators have been called, the fields are parsed as per usual by the built-in <code>pydantic</code> field validation for their respective types.</p> <p>Note</p> <p><code>pydantic-argparse</code> also enhances <code>pydantic</code>'s built-in environment variable parsing capabilities.</p> <p>By default, <code>pydantic</code> attempts to parse complex types as <code>json</code> values. If this parsing fails a <code>pydantic.env_settings.SettingsError</code> is raised and the argument parsing fails immediately with an obscure error message. This means the values never reach the generated <code>pydantic-argparse</code> validators, the user's custom validators or the built-in <code>pydantic</code> field validation.</p> <p>As a solution, <code>pydantic-argparse</code> wraps the existing <code>pydantic.BaseSettings.parse_env_var()</code> environment variable parsing class method to handle this situation. The wrapped parser passes through raw <code>str</code> values unchanged if the <code>json</code> parsing fails. This allows the raw string values to be parsed, validated and handled by the generated <code>pydantic-argparse</code> validators and the built-in <code>pydantic</code> field validators if applicable.</p>"},{"location":"usage/arguments/choices/","title":"Choices","text":""},{"location":"usage/arguments/choices/#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> provides functionality for choice arguments. A choice is a command-line argument that allows a restricted set of values. For example: <code>--choice X</code> or <code>--choice Y</code>.</p> <p>This section covers the following standard <code>argparse</code> argument functionality:</p> <pre><code># Enum Choices\nparser.add_argument(\"--choice\", choices=[Enum.A, Enum.B, Enum.B])\n# Literal Choices\nparser.add_argument(\"--choice\", choices=[\"A\", \"B\", \"C\"])\n</code></pre>"},{"location":"usage/arguments/choices/#usage","title":"Usage","text":"<p>The intended usage of choice arguments is to restrict the set of valid options for the user. For example:</p> <pre><code>$ python3 example.py --choice PAPER\n</code></pre> <pre><code>if args.choice == \"PAPER\":\n    # Choice PAPER\n    ...\nelif args.choice == \"SCISSORS\":\n    # Choice SCISSORS\n    ...\nelif args.choice == \"ROCK\":\n    # Choice ROCK\n    ...\nelse:\n    # This cannot occur!\n    # Something must have gone wrong...\n    ...\n</code></pre>"},{"location":"usage/arguments/choices/#enums","title":"Enums","text":"<p>Enum choices can be created by adding a <code>pydantic</code> <code>Field</code> with the type of an <code>enum.Enum</code> class, which contains more than one enumeration. There are different kinds of enum choice arguments, which are outlined below.</p>"},{"location":"usage/arguments/choices/#required","title":"Required","text":"<p>A required enum choice argument is defined as follows:</p> <pre><code>class Choices(enum.Enum):\n    A = enum.auto()\n    B = enum.auto()\n    C = enum.auto()\n\nclass Arguments(BaseModel):\n    # Required Choice\n    choice: Choices = Field(description=\"this is a required choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] --choice {A, B, C}\n\nrequired arguments:\n  --choice {A, B, C}  this is a required choice\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>Choices.A</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>Choices.B</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>Choices.C</code>.</li> <li>This argument cannot be omitted.</li> </ul>"},{"location":"usage/arguments/choices/#optional-default-none","title":"Optional (Default <code>None</code>)","text":"<p>An optional enum choice argument with a default of <code>None</code> is defined as follows:</p> <pre><code>class Choices(enum.Enum):\n    A = enum.auto()\n    B = enum.auto()\n    C = enum.auto()\n\nclass Arguments(BaseModel):\n    # Optional Choice (Default None)\n    choice: Optional[Choices] = Field(description=\"this is an optional choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--choice {A, B, C}]\n\noptional arguments:\n  --choice {A, B, C}  this is an optional choice (default: None)\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>Choices.A</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>Choices.B</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>Choices.C</code>.</li> <li>Omitting this argument will set <code>args.choice</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/choices/#optional-default-value","title":"Optional (Default <code>Value</code>)","text":"<p>An optional enum choice argument with a default choice is defined as follows:</p> <pre><code>class Choices(enum.Enum):\n    A = enum.auto()\n    B = enum.auto()\n    C = enum.auto()\n\nclass Arguments(BaseModel):\n    # Optional Choice (Default Choices.A)\n    choice: Choices = Field(Choices.A, description=\"this is an optional choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--choice {A, B, C}]\n\noptional arguments:\n  --choice {A, B, C}  this is an optional choice (default: Choices.A)\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>Choices.A</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>Choices.B</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>Choices.C</code>.</li> <li>Omitting this argument will set <code>args.choice</code> to <code>Choices.A</code> (the default).</li> </ul>"},{"location":"usage/arguments/choices/#literals","title":"Literals","text":"<p>Literal choices can be created by adding a <code>pydantic</code> <code>Field</code> with the type of <code>typing.Literal</code>, which contains more than one literal value. There are different kinds of literal flag arguments, which are outlined below.</p>"},{"location":"usage/arguments/choices/#required_1","title":"Required","text":"<p>A required literal choice argument is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Required Choice\n    choice: Literal[\"A\", \"B\", \"C\"] = Field(description=\"this is a required choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] --choice {A, B, C}\n\nrequired arguments:\n  --choice {A, B, C}  this is a required choice\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>\"A\"</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>\"B\"</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>\"C\"</code>.</li> <li>This argument cannot be omitted.</li> </ul>"},{"location":"usage/arguments/choices/#optional-default-none_1","title":"Optional (Default <code>None</code>)","text":"<p>An optional literal choice argument with a default of <code>None</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Choice (Default None)\n    choice: Optional[Literal[\"A\", \"B\", \"C\"]] = Field(description=\"this is an optional choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--choice {A, B, C}]\n\noptional arguments:\n  --choice {A, B, C}  this is an optional choice (default: None)\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>\"A\"</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>\"B\"</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>\"C\"</code>.</li> <li>Omitting this argument will set <code>args.choice</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/choices/#optional-default-value_1","title":"Optional (Default <code>Value</code>)","text":"<p>An optional literal choice argument with a default choice is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Choice (Default \"A\")\n    choice: Literal[\"A\", \"B\", \"C\"] = Field(\"A\", description=\"this is an optional choice\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--choice {A, B, C}]\n\noptional arguments:\n  --choice {A, B, C}  this is an optional choice (default: A)\n\nhelp:\n  -h, --help          show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--choice A</code> will set <code>args.choice</code> to <code>\"A\"</code>.</li> <li>Providing an argument of <code>--choice B</code> will set <code>args.choice</code> to <code>\"B\"</code>.</li> <li>Providing an argument of <code>--choice C</code> will set <code>args.choice</code> to <code>\"C\"</code>.</li> <li>Omitting this argument will set <code>args.choice</code> to <code>\"A\"</code> (the default).</li> </ul>"},{"location":"usage/arguments/commands/","title":"Commands","text":""},{"location":"usage/arguments/commands/#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> provides functionality for commands. A command is a positional command-line argument that can be followed by its own specific subset of command-line arguments. For example: <code>command --arg abc</code>.</p> <p>This section covers the following standard <code>argparse</code> argument functionality:</p> <pre><code># Subparser Commands\nsubparsers = parser.add_subparsers()\ncommand = subparsers.add_parser(\"command\")\ncommand.add_argument(...)\n</code></pre>"},{"location":"usage/arguments/commands/#usage","title":"Usage","text":"<p>The intended usage of commands is to provide the user with different application behaviours, each with their own subset of arguments. For example:</p> <pre><code>$ python3 example.py serve --address 127.0.0.1 --port 8080\n</code></pre> <pre><code>if args.serve:\n    # The serve command was chosen\n    # We have typed access to any of the command model arguments we defined\n    # For example: `args.serve.address`, `args.serve.port`, etc.\n    ...\n</code></pre>"},{"location":"usage/arguments/commands/#pydantic-models","title":"Pydantic Models","text":"<p>Commands can be created by first defining a <code>pydantic</code> model for the command (e.g., <code>Command</code>), containing its own subset of arguments. The command can then be added to the command-line interface by adding a <code>pydantic</code> field with the type of <code>Optional[Command]</code>. Despite each command itself being optional, overall a command is always required, as outlined below.</p>"},{"location":"usage/arguments/commands/#required","title":"Required","text":"<p>Required commands are defined as follows:</p> <pre><code>class Command1(BaseModel):\n    arg1: str = Field(description=\"this is sub-argument 1\")\n\nclass Command2(BaseModel):\n    arg2: str = Field(description=\"this is sub-argument 2\")\n\nclass Arguments(BaseModel):\n    # Commands\n    command1: Optional[Command1] = Field(description=\"this is command 1\")\n    command2: Optional[Command2] = Field(description=\"this is command 2\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] {command1,command2} ...\n\ncommands:\n  {command1,command2}\n    command1           this is command 1\n    command2           this is command 2\n\nhelp:\n  -h, --help           show this help message and exit\n</code></pre> <p>This <code>Arguments</code> model also generates command-line interfaces for each of its commands:</p> <pre><code>$ python3 example.py command1 --help\nusage: example.py command1 [-h] --arg1 ARG1\n\nrequired arguments:\n  --arg1 ARG1  this is sub-argument 1\n\nhelp:\n  -h, --help   show this help message and exit\n</code></pre> <pre><code>$ python3 example.py command2 --help\nusage: example.py command2 [-h] --arg2 ARG2\n\nrequired arguments:\n  --arg2 ARG2  this is sub-argument 2\n\nhelp:\n  -h, --help   show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing arguments of <code>command1 --arg1 abc</code> will set <code>args.command1</code> to   to <code>Command1(arg1=\"abc\")</code>, and <code>args.command2</code> to <code>None</code>.</li> <li>Providing arguments of <code>command2 --arg2 xyz</code> will set <code>args.command2</code> to   to <code>Command2(arg2=\"xyz\")</code>, and <code>args.command1</code> to <code>None</code>.</li> <li>Commands cannot be omitted.</li> </ul>"},{"location":"usage/arguments/flags/","title":"Flags","text":""},{"location":"usage/arguments/flags/#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> provides functionality for flag arguments. A flag is a command-line argument that has no following value. For example: <code>--flag</code> or <code>--no-flag</code>.</p> <p>This section covers the following standard <code>argparse</code> argument functionality:</p> <pre><code># Boolean Flags\nparser.add_argument(\"--flag\", action=argparse.BooleanOptionalAction)\nparser.add_argument(\"--flag\", action=\"store_true\")\nparser.add_argument(\"--no-flag\", action=\"store_false\")\n# Constant Flags\nparser.add_argument(\"--flag\", action=\"store_const\", const=\"A\")\nparser.add_argument(\"--flag\", action=\"store_const\", const=Enum.A)\n</code></pre>"},{"location":"usage/arguments/flags/#usage","title":"Usage","text":"<p>The intended usage of flags is to enable or disable features. For example:</p> <pre><code>$ python3 example.py --debug\n</code></pre> <pre><code>if args.debug:\n    # Set logging to DEBUG\n    ...\n</code></pre>"},{"location":"usage/arguments/flags/#booleans","title":"Booleans","text":"<p>Boolean flags can be created by adding a <code>pydantic</code> <code>Field</code> with the type of <code>bool</code>. There are different kinds of boolean flag arguments, which are outlined below.</p>"},{"location":"usage/arguments/flags/#required","title":"Required","text":"<p>A required boolean flag is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Required Flag\n    flag: bool = Field(description=\"this is a required flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] --flag | --no-flag\n\nrequired arguments:\n  --flag, --no-flag  this is a required flag\n\nhelp:\n  -h, --help         show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--flag</code> will set <code>args.flag</code> to <code>True</code>.</li> <li>Providing an argument of <code>--no-flag</code> will set <code>args.flag</code> to <code>False</code>.</li> <li>This argument cannot be omitted.</li> </ul>"},{"location":"usage/arguments/flags/#optional-default-false","title":"Optional (Default <code>False</code>)","text":"<p>An optional boolean flag with a default of <code>False</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Flag (Default False)\n    flag: bool = Field(False, description=\"this is an optional flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--flag]\n\noptional arguments:\n  --flag      this is an optional flag (default: False)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--flag</code> will set <code>args.flag</code> to <code>True</code>.</li> <li>Omitting this argument will set <code>args.flag</code> to <code>False</code> (the default).</li> </ul>"},{"location":"usage/arguments/flags/#optional-default-true","title":"Optional (Default <code>True</code>)","text":"<p>An optional boolean flag with a default of <code>True</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Flag (Default True)\n    flag: bool = Field(True, description=\"this is an optional flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--no-flag]\n\noptional arguments:\n  --no-flag   this is an optional flag (default: True)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--no-flag</code> will set <code>args.flag</code> to <code>False</code>.</li> <li>Omitting this argument will set <code>args.flag</code> to <code>True</code> (the default).</li> </ul>"},{"location":"usage/arguments/flags/#enums","title":"Enums","text":"<p>Enum flags can be created by adding a <code>pydantic</code> <code>Field</code> with the type of an <code>enum.Enum</code> class, which contains only one enumeration. There are different kinds of enum flag arguments, which are outlined below.</p>"},{"location":"usage/arguments/flags/#optional-default-none","title":"Optional (Default <code>None</code>)","text":"<p>An optional enum flag with a default of <code>None</code> is defined as follows:</p> <pre><code>class Constant(enum.Enum):\n    VALUE = enum.auto()\n\nclass Arguments(BaseModel):\n    # Optional Flag (Default None)\n    constant: Optional[Constant] = Field(description=\"this is a constant flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--constant]\n\noptional arguments:\n  --constant  this is a constant flag (default: None)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--constant</code> will set <code>args.constant</code> to <code>Constant.VALUE</code>.</li> <li>Omitting this argument will set <code>args.constant</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/flags/#optional-default-constant","title":"Optional (Default <code>Constant</code>)","text":"<p>An optional enum flag with a constant default value is defined as follows:</p> <pre><code>class Constant(enum.Enum):\n    VALUE = enum.auto()\n\nclass Arguments(BaseModel):\n    # Optional Flag (Default Constant.VALUE)\n    constant: Optional[Constant] = Field(Constant.VALUE, description=\"this is a constant flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--no-constant]\n\noptional arguments:\n  --no-constant  this is a constant flag (default: Constant.VALUE)\n\nhelp:\n  -h, --help     show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--no-constant</code> will set <code>args.constant</code> to <code>None</code>.</li> <li>Omitting this argument will set <code>args.constant</code> to <code>Constant.VALUE</code> (the default).</li> </ul>"},{"location":"usage/arguments/flags/#literals","title":"Literals","text":"<p>Literal flags can be created by adding a <code>pydantic</code> <code>Field</code> with the type of <code>typing.Literal</code>, which contains only one literal value. There are different kinds of literal flag arguments, which are outlined below.</p>"},{"location":"usage/arguments/flags/#optional-default-none_1","title":"Optional (Default <code>None</code>)","text":"<p>An optional literal flag with a default of <code>None</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Flag (Default None)\n    constant: Optional[Literal[\"VALUE\"]] = Field(description=\"this is a constant flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--constant]\n\noptional arguments:\n  --constant  this is a constant flag (default: None)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--constant</code> will set <code>args.constant</code> to <code>\"VALUE\"</code>.</li> <li>Omitting this argument will set <code>args.constant</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/flags/#optional-default-constant_1","title":"Optional (Default <code>Constant</code>)","text":"<p>An optional literal flag with a constant default value is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Flag (Default \"VALUE\")\n    constant: Optional[Literal[\"VALUE\"]] = Field(\"VALUE\", description=\"this is a constant flag\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--no-constant]\n\noptional arguments:\n  --no-constant  this is a constant flag (default: VALUE)\n\nhelp:\n  -h, --help     show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--no-constant</code> will set <code>args.constant</code> to <code>None</code>.</li> <li>Omitting this argument will set <code>args.constant</code> to <code>\"VALUE\"</code> (the default).</li> </ul>"},{"location":"usage/arguments/regular/","title":"Regular","text":""},{"location":"usage/arguments/regular/#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> provides functionality for regular arguments. A regular argument is a command-line argument that is followed by exactly one value. For example: <code>--arg hello</code>, <code>--arg 123</code> or <code>--arg 42.0</code>.</p> <p>This section covers the following standard <code>argparse</code> argument functionality:</p> <pre><code>parser.add_argument(\"--argument\", type=T)\n</code></pre>"},{"location":"usage/arguments/regular/#usage","title":"Usage","text":"<p>The intended usage of regular arguments is to capture and validate a value from the user for the application. For example:</p> <pre><code>$ python3 example.py --name SupImDos\n</code></pre> <pre><code># We can use the validated command-line arguments in the application\nprint(f\"Hello {args.name}!\")\n</code></pre>"},{"location":"usage/arguments/regular/#singular-types","title":"Singular Types","text":"<p>Regular arguments can be created by adding a <code>pydantic</code> <code>Field</code> with any type that takes \"singular\" values.</p> <p>Some examples of simple \"singular\" inbuilt types:</p> <ul> <li><code>str</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>dict</code></li> </ul> <p>Info</p> <p>For more information about simple inbuilt types, see the <code>pydantic</code> docs</p> <p>Note</p> <p><code>pydantic-argparse</code> handles some types specially, such as:</p> <ul> <li><code>collections.abc.Container</code> (e.g., <code>list</code>, <code>tuple</code>, <code>set</code>)</li> <li><code>bool</code></li> <li><code>enum.Enum</code></li> <li><code>typing.Literal</code></li> <li><code>pydantic.BaseModel</code></li> </ul> <p>The special behaviours of these types are addressed in the following sections.</p> <p>Any type that is able to be validated by <code>pydantic</code> can be used. This allows for advanced argument types, for example:</p> <ul> <li><code>pydantic.FilePath</code></li> <li><code>pydantic.EmailStr</code></li> <li><code>pydantic.AnyUrl</code></li> <li><code>pydantic.IPvAnyAddress</code></li> </ul> <p>Info</p> <p>For more information about advanced <code>pydantic</code> types, see the <code>pydantic</code> docs</p> <p>There are different kinds of regular arguments, which are outlined below.</p>"},{"location":"usage/arguments/regular/#required","title":"Required","text":"<p>A required regular singular argument is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Required Singular Argument\n    # Note: `int` is just an example, any singular type could be used\n    arg: int = Field(description=\"this is a required singular argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] --arg ARG\n\nrequired arguments:\n  --arg ARG   this is a required singular argument\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 42</code> will set <code>args.arg</code> to <code>42</code>.</li> <li>This argument cannot be omitted.</li> </ul>"},{"location":"usage/arguments/regular/#optional-default-none","title":"Optional (Default <code>None</code>)","text":"<p>An optional regular singular argument with a default of <code>None</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Singular Argument\n    # Note: `int` is just an example, any singular type could be used\n    arg: Optional[int] = Field(description=\"this is an optional singular argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--arg ARG]\n\noptional arguments:\n  --arg ARG   this is a required singular argument (default: None)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 42</code> will set <code>args.arg</code> to <code>42</code>.</li> <li>Omitting this argument will set <code>args.arg</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/regular/#optional-default-value","title":"Optional (Default <code>Value</code>)","text":"<p>An optional container variadic argument with a constant default value is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Singular Argument\n    # Note: `int` is just an example, any singular type could be used\n    arg: int = Field(42, description=\"this is an optional singular argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--arg ARG]\n\noptional arguments:\n  --arg ARG   this is a required singular argument (default: 42)\n\nhelp:\n  -h, --help  show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 7</code> will set <code>args.arg</code> to <code>7</code>.</li> <li>Omitting this argument will set <code>args.arg</code> to <code>42</code> (the default).</li> </ul>"},{"location":"usage/arguments/variadic/","title":"Variadic","text":""},{"location":"usage/arguments/variadic/#overview","title":"Overview","text":"<p><code>pydantic-argparse</code> provides functionality for variadic arguments. A variadic argument is a command-line argument that is followed by one or more values. For example: <code>--variadic a b c</code> or <code>--variadic 1 2 3 4 5 6</code>.</p> <p>This section covers the following standard <code>argparse</code> argument functionality:</p> <pre><code>parser.add_argument(\"--variadic\", nargs=\"+\")\n</code></pre>"},{"location":"usage/arguments/variadic/#usage","title":"Usage","text":"<p>The intended usage of variadic arguments is to capture multiple values for an argument. For example:</p> <pre><code>$ python3 example.py --files a.txt b.txt c.txt\n</code></pre> <pre><code>for file in args.files:\n    # We can iterate through all of the values provided by the user\n    ...\n</code></pre>"},{"location":"usage/arguments/variadic/#container-types","title":"Container Types","text":"<p>Variadic arguments can be created by adding a <code>pydantic</code> <code>Field</code> with any type that is a <code>collections.abc.Container</code> type. For example:</p> <ul> <li><code>list[T]</code></li> <li><code>tuple[T]</code></li> <li><code>set[T]</code></li> <li><code>frozenset[T]</code></li> <li><code>deque[T]</code></li> </ul> <p>There are different kinds of container variadic arguments, which are outlined below.</p>"},{"location":"usage/arguments/variadic/#required","title":"Required","text":"<p>A required container variadic argument is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Required Container Argument\n    # Note: `list[int]` is just an example, any container type could be used\n    arg: list[int] = Field(description=\"this is a required variadic argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] --arg ARG [ARG ...]\n\nrequired arguments:\n  --arg ARG [ARG ...]  this is a required variadic argument\n\nhelp:\n  -h, --help           show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 1</code> will set <code>args.arg</code> to <code>[1]</code>.</li> <li>Providing an argument of <code>--arg 1 2 3</code> will set <code>args.arg</code> to <code>[1, 2, 3]</code>.</li> <li>This argument cannot be omitted.</li> </ul>"},{"location":"usage/arguments/variadic/#optional-default-none","title":"Optional (Default <code>None</code>)","text":"<p>An optional container variadic argument with a default of <code>None</code> is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Container Argument\n    # Note: `list[int]` is just an example, any container type could be used\n    arg: Optional[list[int]] = Field(description=\"this is an optional variadic argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--arg ARG [ARG ...]]\n\noptional arguments:\n  --arg ARG [ARG ...]  this is a required variadic argument (default: None)\n\nhelp:\n  -h, --help           show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 1</code> will set <code>args.arg</code> to <code>[1]</code>.</li> <li>Providing an argument of <code>--arg 1 2 3</code> will set <code>args.arg</code> to <code>[1, 2, 3]</code>.</li> <li>Omitting this argument will set <code>args.arg</code> to <code>None</code> (the default).</li> </ul>"},{"location":"usage/arguments/variadic/#optional-default-value","title":"Optional (Default <code>Value</code>)","text":"<p>An optional container variadic argument with a constant default value is defined as follows:</p> <pre><code>class Arguments(BaseModel):\n    # Optional Container Argument\n    # Note: `list[int]` is just an example, any container type could be used\n    arg: list[int] = Field([4, 5, 6], description=\"this is an optional variadic argument\")\n</code></pre> <p>This <code>Arguments</code> model generates the following command-line interface:</p> <pre><code>$ python3 example.py --help\nusage: example.py [-h] [--arg ARG [ARG ...]]\n\noptional arguments:\n  --arg ARG [ARG ...]  this is an optional variadic argument (default: [4, 5, 6])\n\nhelp:\n  -h, --help           show this help message and exit\n</code></pre> <p>Outcomes:</p> <ul> <li>Providing an argument of <code>--arg 1</code> will set <code>args.arg</code> to <code>[1]</code>.</li> <li>Providing an argument of <code>--arg 1 2 3</code> will set <code>args.arg</code> to <code>[1, 2, 3]</code>.</li> <li>Omitting this argument will set <code>args.arg</code> to <code>[4, 5, 6]</code> (the default).</li> </ul>"}]}