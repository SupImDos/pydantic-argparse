{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pydantic Argparse Typed Argument Parsing with Pydantic Overview pydantic-argparse is a Python package built on top of pydantic which provides declarative typed argument parsing using pydantic models. Requirements pydantic-argparse requires Python 3.9+ Installation Installation with pip is simple: $ pip install pydantic-argparse Quick Start Define Model simple.py \"\"\"Simple Example.\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments.\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Parse Arguments $ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True Credits This project is made possible by pydantic . License This project is licensed under the terms of the MIT license.","title":"Overview"},{"location":"#overview","text":"pydantic-argparse is a Python package built on top of pydantic which provides declarative typed argument parsing using pydantic models.","title":"Overview"},{"location":"#requirements","text":"pydantic-argparse requires Python 3.9+","title":"Requirements"},{"location":"#installation","text":"Installation with pip is simple: $ pip install pydantic-argparse","title":"Installation"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#define-model","text":"simple.py \"\"\"Simple Example.\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments.\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"#check-help","text":"$ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"#parse-arguments","text":"$ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Parse Arguments"},{"location":"#credits","text":"This project is made possible by pydantic .","title":"Credits"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"background/","text":"Overview Before delving into the documentation, examples and code reference, it is first necessary to explore and understand why you may want to use this package. Tenets The design goals of pydantic-argparse are summarised by these core tenets. Simple pydantic-argparse has a simple API and code-base. Opinionated pydantic-argparse is deliberately limited with one way of doing things. Typed pydantic-argparse fully supports type-hinting and mypy . Rationale There are many benefits to using pydantic-argparse over a more traditional argument parsing package that uses a functional api. Some of the most valuable benefits are outlined below. Declarative Arguments Arguments are defined declaratively using pydantic models. This means the command-line interface for your application has a strict schema, that is easy to view, modify or even export to other formats such as JSON Schema . Familiar Syntax Due to the use of pydantic models and standard type-hinting, there is almost no new syntax or API to learn. Just declare your interface with a dataclass-like pydantic model, and let pydantic-argparse parse your arguments. Type Hints Due to the use of pydantic models, your parsed command-line arguments are just an instance of a type-hinted class. This means that your arguments can support auto-completion, linting, mypy and other tools in your IDE. Pydantic Validation Due to the use of pydantic models, your command-line interface is able to heavily leverage pydantic 's validation system to provide a very large number of different types. Confidence As a result of type-hinting and pydantic validation, you can have the confidence that once your command-line arguments have been parsed, their type and validity have been confirmed - you don't have to check or worry about them again. Drawbacks There are also some drawbacks to using pydantic-argparse , depending on the size of your project, the features you require and the programming paradigms that you agree with. Some of the possible drawbacks are outlined below. Extra Dependencies While pydantic-argparse itself depends only on pydantic , it has a number of transient dependencies due to the dependencies of pydantic itself. If your application is small, it may not be suitable to pull in pydantic and its dependencies for a simple command-line interface. Opinionated Design pydantic-argparse is a very opinionated package by design. It aims for a simple API, and to be both full featured while limiting excessive choices. For example, there are no positional arguments in pydantic-argparse ; only optional and required arguments. If your opinions do not align with these design choices, then you may not want to use the package. Nested Models Sub-commands are supported by nesting pydantic models. This means that for each sub-command, an additional model must be defined. If your application requires many different sub-commands, it may result in a large number of pydantic models. Alternatives There are many alternative argument parsing packages that already exist for Python. Some of the most popular are outlined below. Argparse argparse is a standard-library module that makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and argparse will figure out how to parse those out of sys.argv . The argparse module also automatically generates help and usage messages and issues errors when users give the program invalid arguments. Click click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box. Typer typer is a library for building CLI applications that users will love using and developers will love creating. Based on Python 3.6+ type hints. The key features are that it is intuitive to write, easy to use, short and starts simple but can grow large. It aims to be the fastapi of command-line interfaces. Comparison A feature comparison matrix of the alternatives outlined above is shown below. argparse click typer pydantic-argparse Arguments Optional Arguments Required Arguments Positional Arguments Sub-Commands Argument Types Regular Arguments Variadic Arguments Flag Arguments Choice Arguments Validation Type Validation Automatic Validation Pydantic Validation Design Pattern Functional Definition Declarative Definition Function Decorators Function Signature Inspection Extra Features Typing Hinting Shell Completion","title":"Background"},{"location":"background/#overview","text":"Before delving into the documentation, examples and code reference, it is first necessary to explore and understand why you may want to use this package.","title":"Overview"},{"location":"background/#tenets","text":"The design goals of pydantic-argparse are summarised by these core tenets.","title":"Tenets"},{"location":"background/#simple","text":"pydantic-argparse has a simple API and code-base.","title":"Simple"},{"location":"background/#opinionated","text":"pydantic-argparse is deliberately limited with one way of doing things.","title":"Opinionated"},{"location":"background/#typed","text":"pydantic-argparse fully supports type-hinting and mypy .","title":"Typed"},{"location":"background/#rationale","text":"There are many benefits to using pydantic-argparse over a more traditional argument parsing package that uses a functional api. Some of the most valuable benefits are outlined below.","title":"Rationale"},{"location":"background/#declarative-arguments","text":"Arguments are defined declaratively using pydantic models. This means the command-line interface for your application has a strict schema, that is easy to view, modify or even export to other formats such as JSON Schema .","title":"Declarative Arguments"},{"location":"background/#familiar-syntax","text":"Due to the use of pydantic models and standard type-hinting, there is almost no new syntax or API to learn. Just declare your interface with a dataclass-like pydantic model, and let pydantic-argparse parse your arguments.","title":"Familiar Syntax"},{"location":"background/#type-hints","text":"Due to the use of pydantic models, your parsed command-line arguments are just an instance of a type-hinted class. This means that your arguments can support auto-completion, linting, mypy and other tools in your IDE.","title":"Type Hints"},{"location":"background/#pydantic-validation","text":"Due to the use of pydantic models, your command-line interface is able to heavily leverage pydantic 's validation system to provide a very large number of different types.","title":"Pydantic Validation"},{"location":"background/#confidence","text":"As a result of type-hinting and pydantic validation, you can have the confidence that once your command-line arguments have been parsed, their type and validity have been confirmed - you don't have to check or worry about them again.","title":"Confidence"},{"location":"background/#drawbacks","text":"There are also some drawbacks to using pydantic-argparse , depending on the size of your project, the features you require and the programming paradigms that you agree with. Some of the possible drawbacks are outlined below.","title":"Drawbacks"},{"location":"background/#extra-dependencies","text":"While pydantic-argparse itself depends only on pydantic , it has a number of transient dependencies due to the dependencies of pydantic itself. If your application is small, it may not be suitable to pull in pydantic and its dependencies for a simple command-line interface.","title":"Extra Dependencies"},{"location":"background/#opinionated-design","text":"pydantic-argparse is a very opinionated package by design. It aims for a simple API, and to be both full featured while limiting excessive choices. For example, there are no positional arguments in pydantic-argparse ; only optional and required arguments. If your opinions do not align with these design choices, then you may not want to use the package.","title":"Opinionated Design"},{"location":"background/#nested-models","text":"Sub-commands are supported by nesting pydantic models. This means that for each sub-command, an additional model must be defined. If your application requires many different sub-commands, it may result in a large number of pydantic models.","title":"Nested Models"},{"location":"background/#alternatives","text":"There are many alternative argument parsing packages that already exist for Python. Some of the most popular are outlined below.","title":"Alternatives"},{"location":"background/#argparse","text":"argparse is a standard-library module that makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and argparse will figure out how to parse those out of sys.argv . The argparse module also automatically generates help and usage messages and issues errors when users give the program invalid arguments.","title":"Argparse"},{"location":"background/#click","text":"click is a Python package for creating beautiful command line interfaces in a composable way with as little code as necessary. It\u2019s the \u201cCommand Line Interface Creation Kit\u201d. It\u2019s highly configurable but comes with sensible defaults out of the box.","title":"Click"},{"location":"background/#typer","text":"typer is a library for building CLI applications that users will love using and developers will love creating. Based on Python 3.6+ type hints. The key features are that it is intuitive to write, easy to use, short and starts simple but can grow large. It aims to be the fastapi of command-line interfaces.","title":"Typer"},{"location":"background/#comparison","text":"A feature comparison matrix of the alternatives outlined above is shown below. argparse click typer pydantic-argparse Arguments Optional Arguments Required Arguments Positional Arguments Sub-Commands Argument Types Regular Arguments Variadic Arguments Flag Arguments Choice Arguments Validation Type Validation Automatic Validation Pydantic Validation Design Pattern Functional Definition Declarative Definition Function Decorators Function Signature Inspection Extra Features Typing Hinting Shell Completion","title":"Comparison"},{"location":"showcase/","text":"Feature Showcase This showcase demonstrates how pydantic-argparse can be useful, by highlighting some of its features and showing how they can be utilised. CLI Construction The pydantic-argparse command-line interface construction is simple. Pydantic Argparse Argparse import pydantic import pydantic_argparse # Declare Arguments class Arguments ( pydantic . BaseModel ): # Required Arguments string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Arguments second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) # Create Parser parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) # Parse Arguments args = parser . parse_typed_args () import argparse # Create Parser parser = argparse . ArgumentParser ( prog = \"Example Program\" , description = \"Example Description\" , epilog = \"Example Epilog\" , add_help = False , ) # Functionally Add Argument Groups required = parser . add_argument_group ( title = \"required arguments\" ) optional = parser . add_argument_group ( title = \"optional arguments\" ) help = parser . add_argument_group ( \"help\" ) # Add Help Actions help . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"show this help message and exit\" , ) help . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"0.0.1\" , help = \"show program's version number and exit\" , ) # Add Required Arguments required . add_argument ( \"--string\" , type = str , required = True , help = \"a required string\" , ) required . add_argument ( \"--integer\" , type = int , required = True , help = \"a required integer\" , ) required . add_argument ( \"--flag\" , action = argparse . BooleanOptionalAction , required = True , help = \"a required flag\" , ) # Add Optional Arguments optional . add_argument ( \"--second-flag\" , action = \"store_true\" , help = \"an optional flag (default: False)\" , ) optional . add_argument ( \"--third-flag\" , action = \"store_false\" , help = \"an optional flag (default: True)\" , ) # Parse Arguments args = parser . parse_args () Auto Completion The pydantic-argparse parsed args support auto-completion in your IDE. Pydantic Argparse Argparse Type Hints The pydantic-argparse parsed args support type-hinting in your IDE. Pydantic Argparse Argparse Type Safety The pydantic-argparse parsed args support type-safety with mypy . Pydantic Argparse Argparse","title":"Showcase"},{"location":"showcase/#feature-showcase","text":"This showcase demonstrates how pydantic-argparse can be useful, by highlighting some of its features and showing how they can be utilised.","title":"Feature Showcase"},{"location":"showcase/#cli-construction","text":"The pydantic-argparse command-line interface construction is simple. Pydantic Argparse Argparse import pydantic import pydantic_argparse # Declare Arguments class Arguments ( pydantic . BaseModel ): # Required Arguments string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Arguments second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) # Create Parser parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) # Parse Arguments args = parser . parse_typed_args () import argparse # Create Parser parser = argparse . ArgumentParser ( prog = \"Example Program\" , description = \"Example Description\" , epilog = \"Example Epilog\" , add_help = False , ) # Functionally Add Argument Groups required = parser . add_argument_group ( title = \"required arguments\" ) optional = parser . add_argument_group ( title = \"optional arguments\" ) help = parser . add_argument_group ( \"help\" ) # Add Help Actions help . add_argument ( \"-h\" , \"--help\" , action = \"help\" , help = \"show this help message and exit\" , ) help . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \"0.0.1\" , help = \"show program's version number and exit\" , ) # Add Required Arguments required . add_argument ( \"--string\" , type = str , required = True , help = \"a required string\" , ) required . add_argument ( \"--integer\" , type = int , required = True , help = \"a required integer\" , ) required . add_argument ( \"--flag\" , action = argparse . BooleanOptionalAction , required = True , help = \"a required flag\" , ) # Add Optional Arguments optional . add_argument ( \"--second-flag\" , action = \"store_true\" , help = \"an optional flag (default: False)\" , ) optional . add_argument ( \"--third-flag\" , action = \"store_false\" , help = \"an optional flag (default: True)\" , ) # Parse Arguments args = parser . parse_args ()","title":"CLI Construction"},{"location":"showcase/#auto-completion","text":"The pydantic-argparse parsed args support auto-completion in your IDE. Pydantic Argparse Argparse","title":"Auto Completion"},{"location":"showcase/#type-hints","text":"The pydantic-argparse parsed args support type-hinting in your IDE. Pydantic Argparse Argparse","title":"Type Hints"},{"location":"showcase/#type-safety","text":"The pydantic-argparse parsed args support type-safety with mypy . Pydantic Argparse Argparse","title":"Type Safety"},{"location":"examples/commands/","text":"Define Model commands.py \"\"\"Commands Example.\"\"\" # Third-Party import pydantic import pydantic_argparse # Typing from typing import Optional class BuildCommand ( pydantic . BaseModel ): \"\"\"Build Command Arguments.\"\"\" # Required Args location : pydantic . FilePath = pydantic . Field ( description = \"build location\" ) class ServeCommand ( pydantic . BaseModel ): \"\"\"Serve Command Arguments.\"\"\" # Required Args address : pydantic . IPvAnyAddress = pydantic . Field ( description = \"serve address\" ) port : int = pydantic . Field ( description = \"serve port\" ) class Arguments ( pydantic . BaseModel ): \"\"\"Command-Line Arguments.\"\"\" # Optional Args verbose : bool = pydantic . Field ( False , description = \"verbose flag\" ) # Commands build : Optional [ BuildCommand ] = pydantic . Field ( description = \"build command\" ) serve : Optional [ ServeCommand ] = pydantic . Field ( description = \"serve command\" ) def main () -> None : \"\"\"Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 examples/commands.py --help usage: Example Program [-h] [-v] [--verbose] {build,serve} ... Example Description commands: {build,serve} build build command serve serve command optional arguments: --verbose verbose flag (default: False) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Check Commands Help $ python3 examples/commands.py build --help usage: Example Program build [-h] --location LOCATION required arguments: --location LOCATION build location help: -h, --help show this help message and exit $ python3 examples/commands.py serve --help usage: Example Program serve [-h] --address ADDRESS --port PORT required arguments: --address ADDRESS serve address --port PORT serve port help: -h, --help show this help message and exit Parse Arguments $ python3 examples/commands.py --verbose serve --address 127 .0.0.1 --port 8080 verbose=True build=None serve=ServeCommand(address=IPv4Address('127.0.0.1'), port=8080)","title":"Commands"},{"location":"examples/commands/#define-model","text":"commands.py \"\"\"Commands Example.\"\"\" # Third-Party import pydantic import pydantic_argparse # Typing from typing import Optional class BuildCommand ( pydantic . BaseModel ): \"\"\"Build Command Arguments.\"\"\" # Required Args location : pydantic . FilePath = pydantic . Field ( description = \"build location\" ) class ServeCommand ( pydantic . BaseModel ): \"\"\"Serve Command Arguments.\"\"\" # Required Args address : pydantic . IPvAnyAddress = pydantic . Field ( description = \"serve address\" ) port : int = pydantic . Field ( description = \"serve port\" ) class Arguments ( pydantic . BaseModel ): \"\"\"Command-Line Arguments.\"\"\" # Optional Args verbose : bool = pydantic . Field ( False , description = \"verbose flag\" ) # Commands build : Optional [ BuildCommand ] = pydantic . Field ( description = \"build command\" ) serve : Optional [ ServeCommand ] = pydantic . Field ( description = \"serve command\" ) def main () -> None : \"\"\"Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"examples/commands/#check-help","text":"$ python3 examples/commands.py --help usage: Example Program [-h] [-v] [--verbose] {build,serve} ... Example Description commands: {build,serve} build build command serve serve command optional arguments: --verbose verbose flag (default: False) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"examples/commands/#check-commands-help","text":"$ python3 examples/commands.py build --help usage: Example Program build [-h] --location LOCATION required arguments: --location LOCATION build location help: -h, --help show this help message and exit $ python3 examples/commands.py serve --help usage: Example Program serve [-h] --address ADDRESS --port PORT required arguments: --address ADDRESS serve address --port PORT serve port help: -h, --help show this help message and exit","title":"Check Commands Help"},{"location":"examples/commands/#parse-arguments","text":"$ python3 examples/commands.py --verbose serve --address 127 .0.0.1 --port 8080 verbose=True build=None serve=ServeCommand(address=IPv4Address('127.0.0.1'), port=8080)","title":"Parse Arguments"},{"location":"examples/simple/","text":"Define Model simple.py \"\"\"Simple Example.\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments.\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main () Check Help $ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog Parse Arguments $ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Simple"},{"location":"examples/simple/#define-model","text":"simple.py \"\"\"Simple Example.\"\"\" # Third-Party import pydantic import pydantic_argparse class Arguments ( pydantic . BaseModel ): \"\"\"Simple Command-Line Arguments.\"\"\" # Required Args string : str = pydantic . Field ( description = \"a required string\" ) integer : int = pydantic . Field ( description = \"a required integer\" ) flag : bool = pydantic . Field ( description = \"a required flag\" ) # Optional Args second_flag : bool = pydantic . Field ( False , description = \"an optional flag\" ) third_flag : bool = pydantic . Field ( True , description = \"an optional flag\" ) def main () -> None : \"\"\"Simple Main Function.\"\"\" # Create Parser and Parse Args parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Example Program\" , description = \"Example Description\" , version = \"0.0.1\" , epilog = \"Example Epilog\" , ) args = parser . parse_typed_args () # Print Args print ( args ) if __name__ == \"__main__\" : main ()","title":"Define Model"},{"location":"examples/simple/#check-help","text":"$ python3 simple.py --help usage: Example Program [-h] [-v] --string STRING --integer INTEGER --flag | --no-flag [--second-flag] [--no-third-flag] Example Description required arguments: --string STRING a required string --integer INTEGER a required integer --flag, --no-flag a required flag optional arguments: --second-flag an optional flag (default: False) --no-third-flag an optional flag (default: True) help: -h, --help show this help message and exit -v, --version show program's version number and exit Example Epilog","title":"Check Help"},{"location":"examples/simple/#parse-arguments","text":"$ python3 simple.py --string hello --integer 42 --flag string='hello' integer=42 flag=True second_flag=False third_flag=True","title":"Parse Arguments"},{"location":"reference/SUMMARY/","text":"pydantic_argparse argparse actions.py parser.py parsers boolean.py command.py container.py enum.py literal.py mapping.py standard.py utils utils.py","title":"SUMMARY"},{"location":"reference/pydantic_argparse/","text":"pydantic_argparse _\u200b_init__.py Declarative Typed Argument Parsing with Pydantic Models. This is the pydantic-argparse package, which contains the classes, methods and functions required for declarative and typed argument parsing with pydantic models. The public interface exposed by this package is the declarative and typed ArgumentParser class, as well as the package \"dunder\" metadata. _\u200b_metadata__.py Single-Source of Truth Package Versioning and Metadata. The pydantic-argparse package uses the pyproject.toml file as a single-source of truth for the package metadata. As such, rather than duplicating the metadata in code here, it is retrieved from the installed package metadata at runtime. The metadata exported are the title , description , version , author and license of the package","title":"pydantic_argparse"},{"location":"reference/pydantic_argparse/#pydantic_argparse","text":"","title":"pydantic_argparse"},{"location":"reference/pydantic_argparse/#__init__py","text":"Declarative Typed Argument Parsing with Pydantic Models. This is the pydantic-argparse package, which contains the classes, methods and functions required for declarative and typed argument parsing with pydantic models. The public interface exposed by this package is the declarative and typed ArgumentParser class, as well as the package \"dunder\" metadata.","title":"_\u200b_init__.py"},{"location":"reference/pydantic_argparse/#__metadata__py","text":"Single-Source of Truth Package Versioning and Metadata. The pydantic-argparse package uses the pyproject.toml file as a single-source of truth for the package metadata. As such, rather than duplicating the metadata in code here, it is retrieved from the installed package metadata at runtime. The metadata exported are the title , description , version , author and license of the package","title":"_\u200b_metadata__.py"},{"location":"reference/pydantic_argparse/argparse/","text":"argparse _\u200b_init__.py Declarative and Typed Argument Parsing. This package contains the classes and methods required for declarative and typed argument parsing. The public interface exposed by this package is the ArgumentParser class, which is intended to be a near drop-in replacement for the Python standard library argparse.ArgumentParser - while providing declarative and typed argument parsing.","title":"argparse"},{"location":"reference/pydantic_argparse/argparse/#argparse","text":"","title":"argparse"},{"location":"reference/pydantic_argparse/argparse/#__init__py","text":"Declarative and Typed Argument Parsing. This package contains the classes and methods required for declarative and typed argument parsing. The public interface exposed by this package is the ArgumentParser class, which is intended to be a near drop-in replacement for the Python standard library argparse.ArgumentParser - while providing declarative and typed argument parsing.","title":"_\u200b_init__.py"},{"location":"reference/pydantic_argparse/argparse/actions/","text":"actions Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. The actions module contains the SubParsersAction class, which is an action that provides recursive namespace nesting when parsing sub-commands. SubParsersAction Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Examples: Construct ArgumentParser : # Create Argument Parser parser = argparse . ArgumentParser () # Add Example Global Argument parser . add_argument ( \"--time\" ) # Add SubParsersAction subparsers = parser . add_subparsers () # Add Example 'walk' Command with Arguments walk = subparsers . add_parser ( \"walk\" ) walk . add_argument ( \"--speed\" ) walk . add_argument ( \"--distance\" ) # Add Example 'talk' Command with Arguments talk = subparsers . add_parser ( \"talk\" ) talk . add_argument ( \"--volume\" ) talk . add_argument ( \"--topic\" ) Parse the Arguments: --time 3 walk --speed 7 --distance 42 Check Resultant Namespaces: Original : Namespace ( time = 3 , speed = 7 , distance = 42 ) Custom : Namespace ( time = 3 , walk = Namespace ( speed = 7 , distance = 42 )) This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. Source code in pydantic_argparse/argparse/actions.py class SubParsersAction ( argparse . _SubParsersAction ): \"\"\"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Example: Construct `ArgumentParser`: ```python # Create Argument Parser parser = argparse.ArgumentParser() # Add Example Global Argument parser.add_argument(\"--time\") # Add SubParsersAction subparsers = parser.add_subparsers() # Add Example 'walk' Command with Arguments walk = subparsers.add_parser(\"walk\") walk.add_argument(\"--speed\") walk.add_argument(\"--distance\") # Add Example 'talk' Command with Arguments talk = subparsers.add_parser(\"talk\") talk.add_argument(\"--volume\") talk.add_argument(\"--topic\") ``` Parse the Arguments: ```console --time 3 walk --speed 7 --distance 42 ``` Check Resultant Namespaces: ```python Original: Namespace(time=3, speed=7, distance=42) Custom: Namespace(time=3, walk=Namespace(speed=7, distance=42)) ``` This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. \"\"\" def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings ) __call__ ( self , parser , namespace , values , option_string = None ) special Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Parameters: Name Type Description Default parser argparse.ArgumentParser Parent argument parser object. required namespace argparse.Namespace Parent namespace being parsed to. required values Union[str, Sequence[Any], None] Arguments to parse. required option_string Optional[str] Optional option string (not used). None Exceptions: Type Description argparse.ArgumentError Raised if subparser name does not exist. Source code in pydantic_argparse/argparse/actions.py def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"actions.py"},{"location":"reference/pydantic_argparse/argparse/actions/#actions","text":"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. The actions module contains the SubParsersAction class, which is an action that provides recursive namespace nesting when parsing sub-commands.","title":"actions"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction","text":"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Examples: Construct ArgumentParser : # Create Argument Parser parser = argparse . ArgumentParser () # Add Example Global Argument parser . add_argument ( \"--time\" ) # Add SubParsersAction subparsers = parser . add_subparsers () # Add Example 'walk' Command with Arguments walk = subparsers . add_parser ( \"walk\" ) walk . add_argument ( \"--speed\" ) walk . add_argument ( \"--distance\" ) # Add Example 'talk' Command with Arguments talk = subparsers . add_parser ( \"talk\" ) talk . add_argument ( \"--volume\" ) talk . add_argument ( \"--topic\" ) Parse the Arguments: --time 3 walk --speed 7 --distance 42 Check Resultant Namespaces: Original : Namespace ( time = 3 , speed = 7 , distance = 42 ) Custom : Namespace ( time = 3 , walk = Namespace ( speed = 7 , distance = 42 )) This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. Source code in pydantic_argparse/argparse/actions.py class SubParsersAction ( argparse . _SubParsersAction ): \"\"\"Recursively Nesting Sub-Parsers Action for Typed Argument Parsing. This custom action differs in functionality from the existing standard argparse SubParsersAction because it nests the resultant sub-namespace directly into the supplied parent namespace, rather than iterating through and updating the parent namespace object with each argument individually. Example: Construct `ArgumentParser`: ```python # Create Argument Parser parser = argparse.ArgumentParser() # Add Example Global Argument parser.add_argument(\"--time\") # Add SubParsersAction subparsers = parser.add_subparsers() # Add Example 'walk' Command with Arguments walk = subparsers.add_parser(\"walk\") walk.add_argument(\"--speed\") walk.add_argument(\"--distance\") # Add Example 'talk' Command with Arguments talk = subparsers.add_parser(\"talk\") talk.add_argument(\"--volume\") talk.add_argument(\"--topic\") ``` Parse the Arguments: ```console --time 3 walk --speed 7 --distance 42 ``` Check Resultant Namespaces: ```python Original: Namespace(time=3, speed=7, distance=42) Custom: Namespace(time=3, walk=Namespace(speed=7, distance=42)) ``` This behaviour results in a final namespace structure which is much easier to parse, where subcommands are easily identified and nested into their own namespace recursively. \"\"\" def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"SubParsersAction"},{"location":"reference/pydantic_argparse/argparse/actions/#pydantic_argparse.argparse.actions.SubParsersAction.__call__","text":"Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Parameters: Name Type Description Default parser argparse.ArgumentParser Parent argument parser object. required namespace argparse.Namespace Parent namespace being parsed to. required values Union[str, Sequence[Any], None] Arguments to parse. required option_string Optional[str] Optional option string (not used). None Exceptions: Type Description argparse.ArgumentError Raised if subparser name does not exist. Source code in pydantic_argparse/argparse/actions.py def __call__ ( self , parser : argparse . ArgumentParser , namespace : argparse . Namespace , values : Union [ str , Sequence [ Any ], None ], option_string : Optional [ str ] = None , ) -> None : \"\"\"Parses arguments into a namespace with the specified subparser. This custom method parses arguments with the specified subparser, then embeds the resultant sub-namespace into the supplied parent namespace. Args: parser (argparse.ArgumentParser): Parent argument parser object. namespace (argparse.Namespace): Parent namespace being parsed to. values (Union[str, Sequence[Any], None]): Arguments to parse. option_string (Optional[str]): Optional option string (not used). Raises: argparse.ArgumentError: Raised if subparser name does not exist. \"\"\" # Check values object is a sequence # In order to not violate the Liskov Substitution Principle (LSP), the # function signature for __call__ must match the base Action class. As # such, this function signature also accepts 'str' and 'None' types for # the values argument. However, in reality, this should only ever be a # list of strings here, so we just do a type cast. values = cast ( list [ str ], values ) # Get Parser Name and Remaining Argument Strings parser_name , * arg_strings = values # Try select the parser try : # Select the parser parser = self . _name_parser_map [ parser_name ] except KeyError as exc : # Parser doesn't exist, raise an exception raise argparse . ArgumentError ( self , f \"unknown parser { parser_name } (choices: { ', ' . join ( self . _name_parser_map ) } )\" ) from exc # Parse all the remaining options into a sub-namespace, then embed this # sub-namespace into the parent namespace subnamespace , arg_strings = parser . parse_known_args ( arg_strings ) setattr ( namespace , parser_name , subnamespace ) # Store any unrecognized options on the parent namespace, so that the # top level parser can decide what to do with them if arg_strings : vars ( namespace ) . setdefault ( argparse . _UNRECOGNIZED_ARGS_ATTR , []) getattr ( namespace , argparse . _UNRECOGNIZED_ARGS_ATTR ) . extend ( arg_strings )","title":"__call__()"},{"location":"reference/pydantic_argparse/argparse/parser/","text":"parser Declarative and Typed Argument Parser. The parser module contains the ArgumentParser class, which provides a declarative method of defining command-line interfaces. The procedure to declaratively define a typed command-line interface is: Define pydantic arguments model Create typed ArgumentParser Parse typed arguments The resultant arguments object returned is an instance of the defined pydantic model. This means that the arguments object and its attributes will be compatible with an IDE, linter or type checker. ArgumentParser Declarative and Typed Argument Parser. The ArgumentParser declaratively generates a command-line interface using the pydantic model specified upon instantiation. The ArgumentParser provides the following argparse functionality: Required Arguments Optional Arguments Subcommands All arguments are named , and positional arguments are not supported. The ArgumentParser provides the method parse_typed_args() to parse command line arguments and return an instance of its bound pydantic model, populated with the parsed and validated user supplied command-line arguments. Source code in pydantic_argparse/argparse/parser.py class ArgumentParser ( argparse . ArgumentParser , Generic [ PydanticModelT ]): \"\"\"Declarative and Typed Argument Parser. The `ArgumentParser` declaratively generates a command-line interface using the `pydantic` model specified upon instantiation. The `ArgumentParser` provides the following `argparse` functionality: * Required Arguments * Optional Arguments * Subcommands All arguments are *named*, and positional arguments are not supported. The `ArgumentParser` provides the method `parse_typed_args()` to parse command line arguments and return an instance of its bound `pydantic` model, populated with the parsed and validated user supplied command-line arguments. \"\"\" # Argument Group Names COMMANDS = \"commands\" REQUIRED = \"required arguments\" OPTIONAL = \"optional arguments\" HELP = \"help\" # Keyword Arguments KWARG_REQUIRED = \"required\" # Exit Codes EXIT_ERROR = 2 def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. argument_default = argparse . SUPPRESS , # Allow `pydantic` to handle defaults. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" ) def _commands ( self ) -> argparse . _SubParsersAction : \"\"\"Creates and Retrieves Subcommands Action for the ArgumentParser. Returns: argparse._SubParsersAction: SubParsersAction for the subcommands. \"\"\" # Check for Existing Sub-Commands Group if not self . _subcommands : # Add Sub-Commands Group self . _subcommands = self . add_subparsers ( title = ArgumentParser . COMMANDS , action = actions . SubParsersAction , required = True , ) # Shuffle Group to the Top for Help Message self . _action_groups . insert ( 0 , self . _action_groups . pop ()) # Return return self . _subcommands def _add_help_flag ( self ) -> None : \"\"\"Adds help flag to argparser.\"\"\" # Add help flag self . _help_group . add_argument ( \"-h\" , \"--help\" , action = argparse . _HelpAction , help = \"show this help message and exit\" , ) def _add_version_flag ( self ) -> None : \"\"\"Adds version flag to argparser.\"\"\" # Add version flag self . _help_group . add_argument ( \"-v\" , \"--version\" , action = argparse . _VersionAction , help = \"show program's version number and exit\" , ) def _add_model ( self , model : type [ PydanticModelT ]) -> None : \"\"\"Adds pydantic model to argument parser. Args: model (type[PydanticModelT]): Pydantic model class to add to the argument parser. \"\"\" # Loop through fields in model for field in model . __fields__ . values (): # Add Field self . _add_field ( field ) def _add_field ( self , field : pydantic . fields . ModelField ) -> None : \"\"\"Adds pydantic field to argument parser. Args: field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Switch on Field Type if parsers . command . should_parse ( field ): # Add Command parsers . command . parse_field ( self . _commands (), field ) elif parsers . boolean . should_parse ( field ): # Add Boolean Field parsers . boolean . parse_field ( self , field ) elif parsers . container . should_parse ( field ): # Add Container Field parsers . container . parse_field ( self , field ) elif parsers . mapping . should_parse ( field ): # Add Mapping Field parsers . mapping . parse_field ( self , field ) elif parsers . literal . should_parse ( field ): # Add Literal Field parsers . literal . parse_field ( self , field ) elif parsers . enum . should_parse ( field ): # Add Enum Field parsers . enum . parse_field ( self , field ) else : # Add Standard Field parsers . standard . parse_field ( self , field ) __init__ ( self , model , prog = None , description = None , version = None , epilog = None , add_help = True , exit_on_error = True ) special Instantiates the Typed Argument Parser with its pydantic model. Parameters: Name Type Description Default model type[PydanticModelT] Pydantic argument model class. required prog Optional[str] Program name for CLI. None description Optional[str] Program description for CLI. None version Optional[str] Program version string for CLI. None epilog Optional[str] Optional text following help message. None add_help bool Whether to add a -h / --help flag. True exit_on_error bool Whether to exit on error. True Source code in pydantic_argparse/argparse/parser.py def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. argument_default = argparse . SUPPRESS , # Allow `pydantic` to handle defaults. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) parse_typed_args ( self , args = None ) Parses command line arguments. If args are not supplied by the user, then they are automatically retrieved from the sys.argv command-line arguments. Parameters: Name Type Description Default args Optional[list[str]] Optional list of arguments to parse. None Returns: Type Description PydanticModelT Populated instance of typed arguments model. Exceptions: Type Description argparse.ArgumentError Raised upon error, if not exiting on error. SystemExit Raised upon error, if exiting on error. Source code in pydantic_argparse/argparse/parser.py def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model add_argument ( self , * args , ** kwargs ) Adds an argument to the ArgumentParser. Parameters: Name Type Description Default *args Any Positional args to be passed to super class method. () **kwargs Any Keyword args to be passed to super class method. {} Returns: Type Description argparse.Action Action generated by the argument. Source code in pydantic_argparse/argparse/parser.py def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) error ( self , message ) Prints a usage message to stderr and exits if required. Parameters: Name Type Description Default message str Message to print to the user. required Exceptions: Type Description argparse.ArgumentError Raised if not exiting on error. SystemExit Raised if exiting on error. Source code in pydantic_argparse/argparse/parser.py def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" )","title":"parser.py"},{"location":"reference/pydantic_argparse/argparse/parser/#parser","text":"Declarative and Typed Argument Parser. The parser module contains the ArgumentParser class, which provides a declarative method of defining command-line interfaces. The procedure to declaratively define a typed command-line interface is: Define pydantic arguments model Create typed ArgumentParser Parse typed arguments The resultant arguments object returned is an instance of the defined pydantic model. This means that the arguments object and its attributes will be compatible with an IDE, linter or type checker.","title":"parser"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser","text":"Declarative and Typed Argument Parser. The ArgumentParser declaratively generates a command-line interface using the pydantic model specified upon instantiation. The ArgumentParser provides the following argparse functionality: Required Arguments Optional Arguments Subcommands All arguments are named , and positional arguments are not supported. The ArgumentParser provides the method parse_typed_args() to parse command line arguments and return an instance of its bound pydantic model, populated with the parsed and validated user supplied command-line arguments. Source code in pydantic_argparse/argparse/parser.py class ArgumentParser ( argparse . ArgumentParser , Generic [ PydanticModelT ]): \"\"\"Declarative and Typed Argument Parser. The `ArgumentParser` declaratively generates a command-line interface using the `pydantic` model specified upon instantiation. The `ArgumentParser` provides the following `argparse` functionality: * Required Arguments * Optional Arguments * Subcommands All arguments are *named*, and positional arguments are not supported. The `ArgumentParser` provides the method `parse_typed_args()` to parse command line arguments and return an instance of its bound `pydantic` model, populated with the parsed and validated user supplied command-line arguments. \"\"\" # Argument Group Names COMMANDS = \"commands\" REQUIRED = \"required arguments\" OPTIONAL = \"optional arguments\" HELP = \"help\" # Keyword Arguments KWARG_REQUIRED = \"required\" # Exit Codes EXIT_ERROR = 2 def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. argument_default = argparse . SUPPRESS , # Allow `pydantic` to handle defaults. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model ) def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs ) def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" ) def _commands ( self ) -> argparse . _SubParsersAction : \"\"\"Creates and Retrieves Subcommands Action for the ArgumentParser. Returns: argparse._SubParsersAction: SubParsersAction for the subcommands. \"\"\" # Check for Existing Sub-Commands Group if not self . _subcommands : # Add Sub-Commands Group self . _subcommands = self . add_subparsers ( title = ArgumentParser . COMMANDS , action = actions . SubParsersAction , required = True , ) # Shuffle Group to the Top for Help Message self . _action_groups . insert ( 0 , self . _action_groups . pop ()) # Return return self . _subcommands def _add_help_flag ( self ) -> None : \"\"\"Adds help flag to argparser.\"\"\" # Add help flag self . _help_group . add_argument ( \"-h\" , \"--help\" , action = argparse . _HelpAction , help = \"show this help message and exit\" , ) def _add_version_flag ( self ) -> None : \"\"\"Adds version flag to argparser.\"\"\" # Add version flag self . _help_group . add_argument ( \"-v\" , \"--version\" , action = argparse . _VersionAction , help = \"show program's version number and exit\" , ) def _add_model ( self , model : type [ PydanticModelT ]) -> None : \"\"\"Adds pydantic model to argument parser. Args: model (type[PydanticModelT]): Pydantic model class to add to the argument parser. \"\"\" # Loop through fields in model for field in model . __fields__ . values (): # Add Field self . _add_field ( field ) def _add_field ( self , field : pydantic . fields . ModelField ) -> None : \"\"\"Adds pydantic field to argument parser. Args: field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Switch on Field Type if parsers . command . should_parse ( field ): # Add Command parsers . command . parse_field ( self . _commands (), field ) elif parsers . boolean . should_parse ( field ): # Add Boolean Field parsers . boolean . parse_field ( self , field ) elif parsers . container . should_parse ( field ): # Add Container Field parsers . container . parse_field ( self , field ) elif parsers . mapping . should_parse ( field ): # Add Mapping Field parsers . mapping . parse_field ( self , field ) elif parsers . literal . should_parse ( field ): # Add Literal Field parsers . literal . parse_field ( self , field ) elif parsers . enum . should_parse ( field ): # Add Enum Field parsers . enum . parse_field ( self , field ) else : # Add Standard Field parsers . standard . parse_field ( self , field )","title":"ArgumentParser"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.__init__","text":"Instantiates the Typed Argument Parser with its pydantic model. Parameters: Name Type Description Default model type[PydanticModelT] Pydantic argument model class. required prog Optional[str] Program name for CLI. None description Optional[str] Program description for CLI. None version Optional[str] Program version string for CLI. None epilog Optional[str] Optional text following help message. None add_help bool Whether to add a -h / --help flag. True exit_on_error bool Whether to exit on error. True Source code in pydantic_argparse/argparse/parser.py def __init__ ( self , model : type [ PydanticModelT ], prog : Optional [ str ] = None , description : Optional [ str ] = None , version : Optional [ str ] = None , epilog : Optional [ str ] = None , add_help : bool = True , exit_on_error : bool = True , ) -> None : \"\"\"Instantiates the Typed Argument Parser with its `pydantic` model. Args: model (type[PydanticModelT]): Pydantic argument model class. prog (Optional[str]): Program name for CLI. description (Optional[str]): Program description for CLI. version (Optional[str]): Program version string for CLI. epilog (Optional[str]): Optional text following help message. add_help (bool): Whether to add a `-h`/`--help` flag. exit_on_error (bool): Whether to exit on error. \"\"\" # Initialise Super Class super () . __init__ ( prog = prog , description = description , epilog = epilog , exit_on_error = exit_on_error , add_help = False , # Always disable the automatic help flag. argument_default = argparse . SUPPRESS , # Allow `pydantic` to handle defaults. ) # Set Model self . model = model # Set Add Help and Exit on Error Flag self . add_help = add_help self . exit_on_error = exit_on_error # Set Version and Model self . version = version self . model = model # Add Arguments Groups self . _subcommands : Optional [ argparse . _SubParsersAction ] = None self . _required_group = self . add_argument_group ( ArgumentParser . REQUIRED ) self . _optional_group = self . add_argument_group ( ArgumentParser . OPTIONAL ) self . _help_group = self . add_argument_group ( ArgumentParser . HELP ) # Add Help and Version Flags if self . add_help : self . _add_help_flag () if self . version : self . _add_version_flag () # Add Arguments from Model self . _add_model ( model )","title":"__init__()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.parse_typed_args","text":"Parses command line arguments. If args are not supplied by the user, then they are automatically retrieved from the sys.argv command-line arguments. Parameters: Name Type Description Default args Optional[list[str]] Optional list of arguments to parse. None Returns: Type Description PydanticModelT Populated instance of typed arguments model. Exceptions: Type Description argparse.ArgumentError Raised upon error, if not exiting on error. SystemExit Raised upon error, if exiting on error. Source code in pydantic_argparse/argparse/parser.py def parse_typed_args ( self , args : Optional [ list [ str ]] = None , ) -> PydanticModelT : \"\"\"Parses command line arguments. If `args` are not supplied by the user, then they are automatically retrieved from the `sys.argv` command-line arguments. Args: args (Optional[list[str]]): Optional list of arguments to parse. Returns: PydanticModelT: Populated instance of typed arguments model. Raises: argparse.ArgumentError: Raised upon error, if not exiting on error. SystemExit: Raised upon error, if exiting on error. \"\"\" # Call Super Class Method namespace = self . parse_args ( args ) # Convert Namespace to Dictionary arguments = utils . namespace_to_dict ( namespace ) # Handle Possible Validation Errors try : # Convert Namespace to Pydantic Model model = self . model . parse_obj ( arguments ) except pydantic . ValidationError as exc : # Catch exception, and use the ArgumentParser.error() method # to report it to the user self . error ( str ( exc )) # Return return model","title":"parse_typed_args()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.add_argument","text":"Adds an argument to the ArgumentParser. Parameters: Name Type Description Default *args Any Positional args to be passed to super class method. () **kwargs Any Keyword args to be passed to super class method. {} Returns: Type Description argparse.Action Action generated by the argument. Source code in pydantic_argparse/argparse/parser.py def add_argument ( self , * args : Any , ** kwargs : Any , ) -> argparse . Action : \"\"\"Adds an argument to the ArgumentParser. Args: *args (Any): Positional args to be passed to super class method. **kwargs (Any): Keyword args to be passed to super class method. Returns: argparse.Action: Action generated by the argument. \"\"\" # Check whether required or optional if kwargs . get ( ArgumentParser . KWARG_REQUIRED ): # Required group = self . _required_group else : # Optional group = self . _optional_group # Return Action return group . add_argument ( * args , ** kwargs )","title":"add_argument()"},{"location":"reference/pydantic_argparse/argparse/parser/#pydantic_argparse.argparse.parser.ArgumentParser.error","text":"Prints a usage message to stderr and exits if required. Parameters: Name Type Description Default message str Message to print to the user. required Exceptions: Type Description argparse.ArgumentError Raised if not exiting on error. SystemExit Raised if exiting on error. Source code in pydantic_argparse/argparse/parser.py def error ( self , message : str ) -> NoReturn : \"\"\"Prints a usage message to `stderr` and exits if required. Args: message (str): Message to print to the user. Raises: argparse.ArgumentError: Raised if not exiting on error. SystemExit: Raised if exiting on error. \"\"\" # Print usage message self . print_usage ( sys . stderr ) # Check whether parser should exit if self . exit_on_error : self . exit ( ArgumentParser . EXIT_ERROR , f \" { self . prog } : error: { message } \\n \" ) # Raise Error raise argparse . ArgumentError ( None , f \" { self . prog } : error: { message } \" )","title":"error()"},{"location":"reference/pydantic_argparse/parsers/","text":"parsers _\u200b_init__.py Parses Pydantic Fields to Command-Line Arguments. This package contains the functions required for parsing pydantic model fields to ArgumentParser command-line arguments. The public interface exposed by this package is the parsing modules, which each contain the should_parse() and parse_field() functions.","title":"parsers"},{"location":"reference/pydantic_argparse/parsers/#parsers","text":"","title":"parsers"},{"location":"reference/pydantic_argparse/parsers/#__init__py","text":"Parses Pydantic Fields to Command-Line Arguments. This package contains the functions required for parsing pydantic model fields to ArgumentParser command-line arguments. The public interface exposed by this package is the parsing modules, which each contain the should_parse() and parse_field() functions.","title":"_\u200b_init__.py"},{"location":"reference/pydantic_argparse/parsers/boolean/","text":"boolean Parses Boolean Pydantic Fields to Command-Line Arguments. The boolean module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses boolean pydantic model fields to ArgumentParser command-line arguments. should_parse ( field ) Checks whether the field should be parsed as a boolean . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a boolean . Source code in pydantic_argparse/parsers/boolean.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `boolean`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `boolean`. \"\"\" # Check and Return return utils . is_field_a ( field , bool ) parse_field ( parser , field ) Adds boolean pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/boolean.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds boolean pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # Booleans can be treated as required or optional flags if field . required : # Add Required Boolean Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . BooleanOptionalAction , help = utils . argument_description ( field . field_info . description ), dest = field . alias , required = True , default = None , # Bug workaround: https://bugs.python.org/issue46080 ) elif default : # Add Optional Boolean Field (Default True) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreFalseAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , required = False , ) else : # Add Optional Boolean Field (Default False) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreTrueAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , required = False , )","title":"boolean.py"},{"location":"reference/pydantic_argparse/parsers/boolean/#boolean","text":"Parses Boolean Pydantic Fields to Command-Line Arguments. The boolean module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses boolean pydantic model fields to ArgumentParser command-line arguments.","title":"boolean"},{"location":"reference/pydantic_argparse/parsers/boolean/#pydantic_argparse.parsers.boolean.should_parse","text":"Checks whether the field should be parsed as a boolean . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a boolean . Source code in pydantic_argparse/parsers/boolean.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `boolean`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `boolean`. \"\"\" # Check and Return return utils . is_field_a ( field , bool )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/boolean/#pydantic_argparse.parsers.boolean.parse_field","text":"Adds boolean pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/boolean.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds boolean pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # Booleans can be treated as required or optional flags if field . required : # Add Required Boolean Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . BooleanOptionalAction , help = utils . argument_description ( field . field_info . description ), dest = field . alias , required = True , default = None , # Bug workaround: https://bugs.python.org/issue46080 ) elif default : # Add Optional Boolean Field (Default True) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreFalseAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , required = False , ) else : # Add Optional Boolean Field (Default False) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreTrueAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/command/","text":"command Parses Nested Pydantic Model Fields to Sub-Commands. The command module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses nested pydantic model fields to ArgumentParser sub-commands. should_parse ( field ) Checks whether the field should be parsed as a command . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a command . Source code in pydantic_argparse/parsers/command.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `command`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `command`. \"\"\" # Check and Return return utils . is_field_a ( field , pydantic . BaseModel ) parse_field ( subparser , field ) Adds command pydantic field to argument parser. Parameters: Name Type Description Default subparser argparse._SubParsersAction Sub-parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/command.py def parse_field ( subparser : argparse . _SubParsersAction , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds command pydantic field to argument parser. Args: subparser (argparse._SubParsersAction): Sub-parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Add Command subparser . add_parser ( field . alias , help = field . field_info . description , model = field . outer_type_ , exit_on_error = False , # Allow top level parser to handle exiting )","title":"command.py"},{"location":"reference/pydantic_argparse/parsers/command/#command","text":"Parses Nested Pydantic Model Fields to Sub-Commands. The command module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses nested pydantic model fields to ArgumentParser sub-commands.","title":"command"},{"location":"reference/pydantic_argparse/parsers/command/#pydantic_argparse.parsers.command.should_parse","text":"Checks whether the field should be parsed as a command . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a command . Source code in pydantic_argparse/parsers/command.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `command`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `command`. \"\"\" # Check and Return return utils . is_field_a ( field , pydantic . BaseModel )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/command/#pydantic_argparse.parsers.command.parse_field","text":"Adds command pydantic field to argument parser. Parameters: Name Type Description Default subparser argparse._SubParsersAction Sub-parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/command.py def parse_field ( subparser : argparse . _SubParsersAction , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds command pydantic field to argument parser. Args: subparser (argparse._SubParsersAction): Sub-parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Add Command subparser . add_parser ( field . alias , help = field . field_info . description , model = field . outer_type_ , exit_on_error = False , # Allow top level parser to handle exiting )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/container/","text":"container Parses Container Pydantic Fields to Command-Line Arguments. The container module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses container pydantic model fields to ArgumentParser command-line arguments. should_parse ( field ) Checks whether the field should be parsed as a container . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a container . Source code in pydantic_argparse/parsers/container.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `container`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `container`. \"\"\" # Check and Return return ( utils . is_field_a ( field , collections . abc . Container ) and not utils . is_field_a ( field , ( collections . abc . Mapping , enum . Enum , str , bytes )) ) parse_field ( parser , field ) Adds container pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/container.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds container pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # Container Types if field . required : # Add Required Container Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , nargs = argparse . ONE_OR_MORE , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Container Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , nargs = argparse . ONE_OR_MORE , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"container.py"},{"location":"reference/pydantic_argparse/parsers/container/#container","text":"Parses Container Pydantic Fields to Command-Line Arguments. The container module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses container pydantic model fields to ArgumentParser command-line arguments.","title":"container"},{"location":"reference/pydantic_argparse/parsers/container/#pydantic_argparse.parsers.container.should_parse","text":"Checks whether the field should be parsed as a container . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a container . Source code in pydantic_argparse/parsers/container.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `container`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `container`. \"\"\" # Check and Return return ( utils . is_field_a ( field , collections . abc . Container ) and not utils . is_field_a ( field , ( collections . abc . Mapping , enum . Enum , str , bytes )) )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/container/#pydantic_argparse.parsers.container.parse_field","text":"Adds container pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/container.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds container pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # Container Types if field . required : # Add Required Container Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , nargs = argparse . ONE_OR_MORE , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Container Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , nargs = argparse . ONE_OR_MORE , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/enum/","text":"enum Parses Enum Pydantic Fields to Command-Line Arguments. The enum module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses enum pydantic model fields to ArgumentParser command-line arguments. should_parse ( field ) Checks whether the field should be parsed as an enum . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as an enum . Source code in pydantic_argparse/parsers/enum.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as an `enum`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as an `enum`. \"\"\" # Check and Return return utils . is_field_a ( field , enum . Enum ) parse_field ( parser , field ) Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/enum.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Enum Type enum_type : type [ enum . Enum ] = field . outer_type_ # Define Custom Type Caster caster = utils . type_caster ( field . alias , _arg_to_enum_member , enum_type = enum_type ) # Get Default default = field . get_default () # Enums are treated as choices if field . required : # Add Required Enum Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = enum_type , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = _enum_choices_metavar ( enum_type ), required = True , ) elif len ( enum_type ) > 1 : # Add Optional Choice parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = enum_type , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = _enum_choices_metavar ( enum_type ), required = False , ) elif default is not None and field . allow_none : # Add Optional Flag (Default Not None) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreConstAction , const = None , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , ) else : # Add Optional Flag (Default None) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreConstAction , const = list ( enum_type )[ 0 ], help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"enum.py"},{"location":"reference/pydantic_argparse/parsers/enum/#enum","text":"Parses Enum Pydantic Fields to Command-Line Arguments. The enum module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses enum pydantic model fields to ArgumentParser command-line arguments.","title":"enum"},{"location":"reference/pydantic_argparse/parsers/enum/#pydantic_argparse.parsers.enum.should_parse","text":"Checks whether the field should be parsed as an enum . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as an enum . Source code in pydantic_argparse/parsers/enum.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as an `enum`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as an `enum`. \"\"\" # Check and Return return utils . is_field_a ( field , enum . Enum )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/enum/#pydantic_argparse.parsers.enum.parse_field","text":"Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/enum.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Enum Type enum_type : type [ enum . Enum ] = field . outer_type_ # Define Custom Type Caster caster = utils . type_caster ( field . alias , _arg_to_enum_member , enum_type = enum_type ) # Get Default default = field . get_default () # Enums are treated as choices if field . required : # Add Required Enum Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = enum_type , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = _enum_choices_metavar ( enum_type ), required = True , ) elif len ( enum_type ) > 1 : # Add Optional Choice parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = enum_type , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = _enum_choices_metavar ( enum_type ), required = False , ) elif default is not None and field . allow_none : # Add Optional Flag (Default Not None) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreConstAction , const = None , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , ) else : # Add Optional Flag (Default None) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreConstAction , const = list ( enum_type )[ 0 ], help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/literal/","text":"literal Parses Literal Pydantic Fields to Command-Line Arguments. The literal module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses literal pydantic model fields to ArgumentParser command-line arguments. should_parse ( field ) Checks whether the field should be parsed as a literal . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a literal . Source code in pydantic_argparse/parsers/literal.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `literal`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `literal`. \"\"\" # Check and Return return utils . is_field_a ( field , Literal ) parse_field ( parser , field ) Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/literal.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get choices from literal choices = list ( typing . get_args ( field . outer_type_ )) # Define Custom Type Caster caster = utils . type_caster ( field . alias , _arg_to_choice , choices = choices ) # Get Default default = field . get_default () # Literals are treated as constant flags, or choices if field . required : # Add Required Literal Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = choices , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = _iterable_choices_metavar ( choices ), required = True , ) elif len ( choices ) > 1 : # Add Optional Choice parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = choices , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = _iterable_choices_metavar ( choices ), required = False , ) elif default is not None and field . allow_none : # Add Optional Flag (Default Not None) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreConstAction , const = None , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , ) else : # Add Optional Flag (Default None) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreConstAction , const = choices [ 0 ], help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"literal.py"},{"location":"reference/pydantic_argparse/parsers/literal/#literal","text":"Parses Literal Pydantic Fields to Command-Line Arguments. The literal module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses literal pydantic model fields to ArgumentParser command-line arguments.","title":"literal"},{"location":"reference/pydantic_argparse/parsers/literal/#pydantic_argparse.parsers.literal.should_parse","text":"Checks whether the field should be parsed as a literal . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a literal . Source code in pydantic_argparse/parsers/literal.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `literal`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `literal`. \"\"\" # Check and Return return utils . is_field_a ( field , Literal )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/literal/#pydantic_argparse.parsers.literal.parse_field","text":"Adds enum pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/literal.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds enum pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get choices from literal choices = list ( typing . get_args ( field . outer_type_ )) # Define Custom Type Caster caster = utils . type_caster ( field . alias , _arg_to_choice , choices = choices ) # Get Default default = field . get_default () # Literals are treated as constant flags, or choices if field . required : # Add Required Literal Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = choices , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = _iterable_choices_metavar ( choices ), required = True , ) elif len ( choices ) > 1 : # Add Optional Choice parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , choices = choices , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = _iterable_choices_metavar ( choices ), required = False , ) elif default is not None and field . allow_none : # Add Optional Flag (Default Not None) parser . add_argument ( utils . argument_name ( f \"no- { field . alias } \" ), action = argparse . _StoreConstAction , const = None , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , ) else : # Add Optional Flag (Default None) parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreConstAction , const = choices [ 0 ], help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/mapping/","text":"mapping Parses Mapping Pydantic Fields to Command-Line Arguments. The mapping module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses mapping pydantic model fields to ArgumentParser command-line arguments. should_parse ( field ) Checks whether the field should be parsed as a mapping . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a mapping . Source code in pydantic_argparse/parsers/mapping.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `mapping`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `mapping`. \"\"\" # Check and Return return utils . is_field_a ( field , collections . abc . Mapping ) parse_field ( parser , field ) Adds mapping pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/mapping.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds mapping pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Define Custom Type Caster caster = utils . type_caster ( field . alias , ast . literal_eval ) # Get Default default = field . get_default () # Mapping if field . required : # Add Required Mapping Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Mapping Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"mapping.py"},{"location":"reference/pydantic_argparse/parsers/mapping/#mapping","text":"Parses Mapping Pydantic Fields to Command-Line Arguments. The mapping module contains the should_parse function, which checks whether this module should be used to parse the field, as well as the parse_field function, which parses mapping pydantic model fields to ArgumentParser command-line arguments.","title":"mapping"},{"location":"reference/pydantic_argparse/parsers/mapping/#pydantic_argparse.parsers.mapping.should_parse","text":"Checks whether the field should be parsed as a mapping . Parameters: Name Type Description Default field pydantic.fields.ModelField Field to check. required Returns: Type Description bool Whether the field should be parsed as a mapping . Source code in pydantic_argparse/parsers/mapping.py def should_parse ( field : pydantic . fields . ModelField ) -> bool : \"\"\"Checks whether the field should be parsed as a `mapping`. Args: field (pydantic.fields.ModelField): Field to check. Returns: bool: Whether the field should be parsed as a `mapping`. \"\"\" # Check and Return return utils . is_field_a ( field , collections . abc . Mapping )","title":"should_parse()"},{"location":"reference/pydantic_argparse/parsers/mapping/#pydantic_argparse.parsers.mapping.parse_field","text":"Adds mapping pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/mapping.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds mapping pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Define Custom Type Caster caster = utils . type_caster ( field . alias , ast . literal_eval ) # Get Default default = field . get_default () # Mapping if field . required : # Add Required Mapping Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Mapping Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , type = caster , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/parsers/standard/","text":"standard Parses Standard Pydantic Fields to Command-Line Arguments. The standard module contains the parse_field function, which parses standard pydantic model fields to ArgumentParser command-line arguments. Unlike the other parser modules, the standard module does not contain a should_parse function. This is because it is the fallback case, where fields that do not match any other types and require no special handling are parsed. parse_field ( parser , field ) Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/standard.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # All other types are treated in a standard way if field . required : # Add Required Standard Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Standard Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"standard.py"},{"location":"reference/pydantic_argparse/parsers/standard/#standard","text":"Parses Standard Pydantic Fields to Command-Line Arguments. The standard module contains the parse_field function, which parses standard pydantic model fields to ArgumentParser command-line arguments. Unlike the other parser modules, the standard module does not contain a should_parse function. This is because it is the fallback case, where fields that do not match any other types and require no special handling are parsed.","title":"standard"},{"location":"reference/pydantic_argparse/parsers/standard/#pydantic_argparse.parsers.standard.parse_field","text":"Adds standard pydantic field to argument parser. Parameters: Name Type Description Default parser argparse.ArgumentParser Argument parser to add to. required field pydantic.fields.ModelField Field to be added to parser. required Source code in pydantic_argparse/parsers/standard.py def parse_field ( parser : argparse . ArgumentParser , field : pydantic . fields . ModelField , ) -> None : \"\"\"Adds standard pydantic field to argument parser. Args: parser (argparse.ArgumentParser): Argument parser to add to. field (pydantic.fields.ModelField): Field to be added to parser. \"\"\" # Get Default default = field . get_default () # All other types are treated in a standard way if field . required : # Add Required Standard Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , help = utils . argument_description ( field . field_info . description ), dest = field . alias , metavar = field . alias . upper (), required = True , ) else : # Add Optional Standard Field parser . add_argument ( utils . argument_name ( field . alias ), action = argparse . _StoreAction , help = utils . argument_description ( field . field_info . description , default ), dest = field . alias , metavar = field . alias . upper (), required = False , )","title":"parse_field()"},{"location":"reference/pydantic_argparse/utils/","text":"utils _\u200b_init__.py Utility Functions for Declarative Typed Argument Parsing. This package contains helper functions for the typed argument parsing process, including formatting argument names and descriptions, recursively parsing argparse.Namespace objects to dict s, constructing named partial type casting functions and checking the types of pydantic fields. The public interface exposed by this package is various utility helper methods.","title":"utils"},{"location":"reference/pydantic_argparse/utils/#utils","text":"","title":"utils"},{"location":"reference/pydantic_argparse/utils/#__init__py","text":"Utility Functions for Declarative Typed Argument Parsing. This package contains helper functions for the typed argument parsing process, including formatting argument names and descriptions, recursively parsing argparse.Namespace objects to dict s, constructing named partial type casting functions and checking the types of pydantic fields. The public interface exposed by this package is various utility helper methods.","title":"_\u200b_init__.py"},{"location":"reference/pydantic_argparse/utils/utils/","text":"utils Utility Functions for Declarative Typed Argument Parsing. The utils module contains various utility functions, including: argument_name : Formats argument names. argument_description : Formats argument descriptions. namespace_to_dict : Recursively parses argparse.Namespace s to dict s. type_caster : Constructs named functools.partial type casting functions. is_field_a : Checks and compares the types of pydantic fields. The functionality outlined above is so common throughout the typed argument parsing process that the functions have been refactored out into this module as utility functions. argument_name ( name ) Standardises argument name. Examples: argument_name ( \"hello\" ) == \"--hello\" argument_name ( \"hello_world\" ) == \"--hello-world\" Parameters: Name Type Description Default name str Name of the argument. required Returns: Type Description str Standardised name of the argument. Source code in pydantic_argparse/utils/utils.py def argument_name ( name : str ) -> str : \"\"\"Standardises argument name. Examples: ```python argument_name(\"hello\") == \"--hello\" argument_name(\"hello_world\") == \"--hello-world\" ``` Args: name (str): Name of the argument. Returns: str: Standardised name of the argument. \"\"\" # Add '--', replace '_' with '-' return f \"-- { name . replace ( '_' , '-' ) } \" argument_description ( description , default =~ MISSING ) Standardises argument description. Examples: argument_description ( \"hello\" ) == \"hello\" argument_description ( \"hello\" , None ) == \"hello (default: None)\" argument_description ( \"hello\" , 42 ) == \"hello (default: 42)\" Parameters: Name Type Description Default description Optional[str] Optional description for argument. required default Optional[Any] Default value for argument if applicable. ~MISSING Returns: Type Description str Standardised description of the argument. Source code in pydantic_argparse/utils/utils.py def argument_description ( description : Optional [ str ], default : Optional [ Any ] = MISSING , ) -> str : \"\"\"Standardises argument description. Examples: ```python argument_description(\"hello\") == \"hello\" argument_description(\"hello\", None) == \"hello (default: None)\" argument_description(\"hello\", 42) == \"hello (default: 42)\" ``` Args: description (Optional[str]): Optional description for argument. default (Optional[Any]): Default value for argument if applicable. Returns: str: Standardised description of the argument. \"\"\" # Construct Default String default = f \"(default: { default } )\" if default is not MISSING else None # Return Standardised Description String return \" \" . join ( filter ( None , [ description , default ])) namespace_to_dict ( namespace ) Converts a nested namespace to a dictionary recursively. Parameters: Name Type Description Default namespace argparse.Namespace Namespace object to convert. required Returns: Type Description dict[str, Any] Nested dictionary generated from namespace. Source code in pydantic_argparse/utils/utils.py def namespace_to_dict ( namespace : argparse . Namespace ) -> dict [ str , Any ]: \"\"\"Converts a nested namespace to a dictionary recursively. Args: namespace (argparse.Namespace): Namespace object to convert. Returns: dict[str, Any]: Nested dictionary generated from namespace. \"\"\" # Get Dictionary from Namespace Vars dictionary = vars ( namespace ) # Loop Through Dictionary for ( key , value ) in dictionary . items (): # Check for Namespace Objects if isinstance ( value , argparse . Namespace ): # Recurse dictionary [ key ] = namespace_to_dict ( value ) # Return return dictionary type_caster ( name , function , ** kwargs ) Wraps a function to provide a type caster. Parameters: Name Type Description Default name str Name of the type caster (for nicer error messages) required function Callable[..., T] Callable function for type caster. required **kwargs Any Keyword arguments to pass to function. {} Returns: Type Description Callable[[str], T] Type caster named partial function. Source code in pydantic_argparse/utils/utils.py def type_caster ( name : str , function : Callable [ ... , T ], ** kwargs : Any , ) -> Callable [[ str ], T ]: \"\"\"Wraps a function to provide a type caster. Args: name (str): Name of the type caster (for nicer error messages) function (Callable[..., T]): Callable function for type caster. **kwargs (Any): Keyword arguments to pass to function. Returns: Callable[[str], T]: Type caster named partial function. \"\"\" # Set Name, Create Partial Function and Update Wrapper function . __name__ = name partial = functools . partial ( function , ** kwargs ) functools . update_wrapper ( partial , function ) # Return return partial is_field_a ( field , types ) Checks whether the subject is any of the supplied types. The checks are performed as follows: field is one of the types field is an instance of one of the types field is a subclass of one of the types If any of these conditions are True , then the function returns True , else False . Parameters: Name Type Description Default field pydantic.fields.ModelField Subject field to check type of. required types Union[Any, tuple[Any, ...]] Type(s) to compare field against. required Returns: Type Description bool Whether the field is considered one of the types. Source code in pydantic_argparse/utils/utils.py def is_field_a ( field : pydantic . fields . ModelField , types : Union [ Any , tuple [ Any , ... ]], ) -> bool : \"\"\"Checks whether the subject *is* any of the supplied types. The checks are performed as follows: 1. `field` *is* one of the `types` 2. `field` *is an instance* of one of the `types` 3. `field` *is a subclass* of one of the `types` If any of these conditions are `True`, then the function returns `True`, else `False`. Args: field (pydantic.fields.ModelField): Subject field to check type of. types (Union[Any, tuple[Any, ...]]): Type(s) to compare field against. Returns: bool: Whether the field *is* considered one of the types. \"\"\" # Create tuple if only one type was provided if not isinstance ( types , tuple ): types = ( types , ) # Get field type, or origin if applicable field_type = typing . get_origin ( field . outer_type_ ) or field . outer_type_ # Check `isinstance` and `issubclass` validity # In order for `isinstance` and `issubclass` to be valid, all arguments # should be instances of `type`, otherwise `TypeError` *may* be raised. is_valid = all ( isinstance ( t , type ) for t in ( * types , field_type )) # Perform checks and return return ( field_type in types or ( is_valid and isinstance ( field_type , types )) or ( is_valid and issubclass ( field_type , types )) )","title":"utils.py"},{"location":"reference/pydantic_argparse/utils/utils/#utils","text":"Utility Functions for Declarative Typed Argument Parsing. The utils module contains various utility functions, including: argument_name : Formats argument names. argument_description : Formats argument descriptions. namespace_to_dict : Recursively parses argparse.Namespace s to dict s. type_caster : Constructs named functools.partial type casting functions. is_field_a : Checks and compares the types of pydantic fields. The functionality outlined above is so common throughout the typed argument parsing process that the functions have been refactored out into this module as utility functions.","title":"utils"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.argument_name","text":"Standardises argument name. Examples: argument_name ( \"hello\" ) == \"--hello\" argument_name ( \"hello_world\" ) == \"--hello-world\" Parameters: Name Type Description Default name str Name of the argument. required Returns: Type Description str Standardised name of the argument. Source code in pydantic_argparse/utils/utils.py def argument_name ( name : str ) -> str : \"\"\"Standardises argument name. Examples: ```python argument_name(\"hello\") == \"--hello\" argument_name(\"hello_world\") == \"--hello-world\" ``` Args: name (str): Name of the argument. Returns: str: Standardised name of the argument. \"\"\" # Add '--', replace '_' with '-' return f \"-- { name . replace ( '_' , '-' ) } \"","title":"argument_name()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.argument_description","text":"Standardises argument description. Examples: argument_description ( \"hello\" ) == \"hello\" argument_description ( \"hello\" , None ) == \"hello (default: None)\" argument_description ( \"hello\" , 42 ) == \"hello (default: 42)\" Parameters: Name Type Description Default description Optional[str] Optional description for argument. required default Optional[Any] Default value for argument if applicable. ~MISSING Returns: Type Description str Standardised description of the argument. Source code in pydantic_argparse/utils/utils.py def argument_description ( description : Optional [ str ], default : Optional [ Any ] = MISSING , ) -> str : \"\"\"Standardises argument description. Examples: ```python argument_description(\"hello\") == \"hello\" argument_description(\"hello\", None) == \"hello (default: None)\" argument_description(\"hello\", 42) == \"hello (default: 42)\" ``` Args: description (Optional[str]): Optional description for argument. default (Optional[Any]): Default value for argument if applicable. Returns: str: Standardised description of the argument. \"\"\" # Construct Default String default = f \"(default: { default } )\" if default is not MISSING else None # Return Standardised Description String return \" \" . join ( filter ( None , [ description , default ]))","title":"argument_description()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.namespace_to_dict","text":"Converts a nested namespace to a dictionary recursively. Parameters: Name Type Description Default namespace argparse.Namespace Namespace object to convert. required Returns: Type Description dict[str, Any] Nested dictionary generated from namespace. Source code in pydantic_argparse/utils/utils.py def namespace_to_dict ( namespace : argparse . Namespace ) -> dict [ str , Any ]: \"\"\"Converts a nested namespace to a dictionary recursively. Args: namespace (argparse.Namespace): Namespace object to convert. Returns: dict[str, Any]: Nested dictionary generated from namespace. \"\"\" # Get Dictionary from Namespace Vars dictionary = vars ( namespace ) # Loop Through Dictionary for ( key , value ) in dictionary . items (): # Check for Namespace Objects if isinstance ( value , argparse . Namespace ): # Recurse dictionary [ key ] = namespace_to_dict ( value ) # Return return dictionary","title":"namespace_to_dict()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.type_caster","text":"Wraps a function to provide a type caster. Parameters: Name Type Description Default name str Name of the type caster (for nicer error messages) required function Callable[..., T] Callable function for type caster. required **kwargs Any Keyword arguments to pass to function. {} Returns: Type Description Callable[[str], T] Type caster named partial function. Source code in pydantic_argparse/utils/utils.py def type_caster ( name : str , function : Callable [ ... , T ], ** kwargs : Any , ) -> Callable [[ str ], T ]: \"\"\"Wraps a function to provide a type caster. Args: name (str): Name of the type caster (for nicer error messages) function (Callable[..., T]): Callable function for type caster. **kwargs (Any): Keyword arguments to pass to function. Returns: Callable[[str], T]: Type caster named partial function. \"\"\" # Set Name, Create Partial Function and Update Wrapper function . __name__ = name partial = functools . partial ( function , ** kwargs ) functools . update_wrapper ( partial , function ) # Return return partial","title":"type_caster()"},{"location":"reference/pydantic_argparse/utils/utils/#pydantic_argparse.utils.utils.is_field_a","text":"Checks whether the subject is any of the supplied types. The checks are performed as follows: field is one of the types field is an instance of one of the types field is a subclass of one of the types If any of these conditions are True , then the function returns True , else False . Parameters: Name Type Description Default field pydantic.fields.ModelField Subject field to check type of. required types Union[Any, tuple[Any, ...]] Type(s) to compare field against. required Returns: Type Description bool Whether the field is considered one of the types. Source code in pydantic_argparse/utils/utils.py def is_field_a ( field : pydantic . fields . ModelField , types : Union [ Any , tuple [ Any , ... ]], ) -> bool : \"\"\"Checks whether the subject *is* any of the supplied types. The checks are performed as follows: 1. `field` *is* one of the `types` 2. `field` *is an instance* of one of the `types` 3. `field` *is a subclass* of one of the `types` If any of these conditions are `True`, then the function returns `True`, else `False`. Args: field (pydantic.fields.ModelField): Subject field to check type of. types (Union[Any, tuple[Any, ...]]): Type(s) to compare field against. Returns: bool: Whether the field *is* considered one of the types. \"\"\" # Create tuple if only one type was provided if not isinstance ( types , tuple ): types = ( types , ) # Get field type, or origin if applicable field_type = typing . get_origin ( field . outer_type_ ) or field . outer_type_ # Check `isinstance` and `issubclass` validity # In order for `isinstance` and `issubclass` to be valid, all arguments # should be instances of `type`, otherwise `TypeError` *may* be raised. is_valid = all ( isinstance ( t , type ) for t in ( * types , field_type )) # Perform checks and return return ( field_type in types or ( is_valid and isinstance ( field_type , types )) or ( is_valid and issubclass ( field_type , types )) )","title":"is_field_a()"},{"location":"usage/argument_parser/","text":"Overview The interface for pydantic-argparse is the custom typed ArgumentParser class, which provides declarative, typed argument parsing. This ArgumentParser class presents a very similar interface to the python standard library argparse.ArgumentParser , in an attempt to provide as close to a drop-in-replacement as possible. Parser Instantiation To create an instance of the ArgumentParser : parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Program Name\" , description = \"Program Description\" , version = \"1.2.3\" , epilog = \"Program Epilog\" , add_help = True , exit_on_error = True , ) Required Parameters The required parameters for the ArgumentParser are outlined below: model ( type[pydantic.BaseModel] ): The model that defines the command-line arguments Optional Parameters The optional parameters for the ArgumentParser are outlined below: prog ( Optional[str] ): The program name that appears in the help message description ( Optional[str] ): The program description that appears in the help message version ( Optional[str] ): The program version that appears in the help message epilog ( Optional[str] ): The program epilog that appears in the help message add_help ( bool ): Whether to add the -h / --help help message action exit_on_error ( bool ): Whether to exit, or raise an ArgumentError upon an error Argument Parsing To parse command-line arguments into the model using the ArgumentParser : args = parser . parse_typed_args () Info The ArgumentParser is generic over its pydantic model . This means that the parsed args object is type-hinted as an instance of its model . Optional Parameters The optional parameters for the parse_typed_args method are outlined below: args ( Optional[list[str]] ): Optional list of arguments to parse instead of sys.argv","title":"Argument Parser"},{"location":"usage/argument_parser/#overview","text":"The interface for pydantic-argparse is the custom typed ArgumentParser class, which provides declarative, typed argument parsing. This ArgumentParser class presents a very similar interface to the python standard library argparse.ArgumentParser , in an attempt to provide as close to a drop-in-replacement as possible.","title":"Overview"},{"location":"usage/argument_parser/#parser-instantiation","text":"To create an instance of the ArgumentParser : parser = pydantic_argparse . ArgumentParser ( model = Arguments , prog = \"Program Name\" , description = \"Program Description\" , version = \"1.2.3\" , epilog = \"Program Epilog\" , add_help = True , exit_on_error = True , )","title":"Parser Instantiation"},{"location":"usage/argument_parser/#required-parameters","text":"The required parameters for the ArgumentParser are outlined below: model ( type[pydantic.BaseModel] ): The model that defines the command-line arguments","title":"Required Parameters"},{"location":"usage/argument_parser/#optional-parameters","text":"The optional parameters for the ArgumentParser are outlined below: prog ( Optional[str] ): The program name that appears in the help message description ( Optional[str] ): The program description that appears in the help message version ( Optional[str] ): The program version that appears in the help message epilog ( Optional[str] ): The program epilog that appears in the help message add_help ( bool ): Whether to add the -h / --help help message action exit_on_error ( bool ): Whether to exit, or raise an ArgumentError upon an error","title":"Optional Parameters"},{"location":"usage/argument_parser/#argument-parsing","text":"To parse command-line arguments into the model using the ArgumentParser : args = parser . parse_typed_args () Info The ArgumentParser is generic over its pydantic model . This means that the parsed args object is type-hinted as an instance of its model .","title":"Argument Parsing"},{"location":"usage/argument_parser/#optional-parameters_1","text":"The optional parameters for the parse_typed_args method are outlined below: args ( Optional[list[str]] ): Optional list of arguments to parse instead of sys.argv","title":"Optional Parameters"},{"location":"usage/arguments/","text":"Overview At the core of pydantic-argparse is the pydantic model , in which arguments are declared with pydantic fields . This combination of the model and its fields defines the schema for your command-line arguments. Pydantic Models A pydantic model is simply a dataclass-like class that inherits from the pydantic.BaseModel base class. In pydantic-argparse , this model is used to declaratively define your command-line arguments. class Arguments ( BaseModel ): # Required string : str integer : int number : float # Optional boolean : bool = False Arbitrary data, such as raw command-line arguments, can be passed to a model. After parsing and validation pydantic guarantees that the fields of the resultant model instance will conform to the field types defined on the model. Info For more information about pydantic models, see the pydantic docs . Fields A pydantic model contains fields , which are the model class attributes. These fields define each pydantic-argparse command-line argument, and they can be declared either implicitly (as above), or explicitly (as below). class Arguments ( BaseModel ): # Required string : str = Field ( description = \"this argument is a string\" ) integer : int = Field ( description = \"this argument is an integer\" ) number : float = Field ( description = \"this argument is a number\" ) # Optional boolean : bool = Field ( False , description = \"this argument is a boolean\" ) Explicitly defining fields can provide extra information about an argument, either for the command-line interface, the model schema or features such as complex validation. Info For more information about pydantic fields, see the pydantic docs . Arguments Required A field defines a required argument if it has no default value, or a default value of the Ellipses ( ... ) singleton object. class Arguments ( BaseModel ): a : int b : int = ... c : int = Field () d : int = Field ( ... ) Optional A field defines an optional argument if it has a default value. class Arguments ( BaseModel ): a : int = 42 b : int = Field ( 42 ) A field can also define an optional argument if it is type-hinted as Optional . This type-hinting also allows the value of None for the field. class Arguments ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : Optional [ int ] = Field () d : Optional [ int ] = Field ( None ) Descriptions A field can be provided with a description , which will appear in the command-line interface help message. class Arguments ( BaseModel ): a : int = Field ( description = \"this is the command-line description!\" ) Aliases A field can be provided with an alias , which will change the argument name in the command-line interface. class Arguments ( BaseModel ): # We want our argument to be named `class` (i.e., `--class`), but `class` # is a reserved keyword in Python. To accomplish this, we can use the Field # `alias` to override the argument name. class_argument : int = Field ( alias = \"class\" ) Tip This feature allows you to define arguments that use a reserved python keyword as the name. For example: class , continue , async . You can see the list of reserved keywords in Python at any time by typing help ( \"keywords\" ) into the Python interpreter. Validation When parsing command-line arguments with parser.parse_typed_args() , the raw values are parsed and validated using pydantic . The parser has different behaviours depending on whether the supplied command-line arguments are valid. Consider the following example model: class Arguments ( BaseModel ): integer : int Success When the provided command-line arguments satisfy the pydantic model, a populated instance of the model is returned $ python3 example.py --integer 42 Arguments(integer=42) Failure When the provided command-line arguments do not satisfy the pydantic model, the ArgumentParser will provide an error to the user. For example: $ python3 example.py --integer hello usage: example.py [-h] --integer INTEGER example.py: error: 1 validation error for Arguments integer value is not a valid integer (type=type_error.integer) Note The validation error shown to the user is the same as the error that pydantic returns to the user with a ValidationError","title":"Arguments"},{"location":"usage/arguments/#overview","text":"At the core of pydantic-argparse is the pydantic model , in which arguments are declared with pydantic fields . This combination of the model and its fields defines the schema for your command-line arguments.","title":"Overview"},{"location":"usage/arguments/#pydantic","text":"","title":"Pydantic"},{"location":"usage/arguments/#models","text":"A pydantic model is simply a dataclass-like class that inherits from the pydantic.BaseModel base class. In pydantic-argparse , this model is used to declaratively define your command-line arguments. class Arguments ( BaseModel ): # Required string : str integer : int number : float # Optional boolean : bool = False Arbitrary data, such as raw command-line arguments, can be passed to a model. After parsing and validation pydantic guarantees that the fields of the resultant model instance will conform to the field types defined on the model. Info For more information about pydantic models, see the pydantic docs .","title":"Models"},{"location":"usage/arguments/#fields","text":"A pydantic model contains fields , which are the model class attributes. These fields define each pydantic-argparse command-line argument, and they can be declared either implicitly (as above), or explicitly (as below). class Arguments ( BaseModel ): # Required string : str = Field ( description = \"this argument is a string\" ) integer : int = Field ( description = \"this argument is an integer\" ) number : float = Field ( description = \"this argument is a number\" ) # Optional boolean : bool = Field ( False , description = \"this argument is a boolean\" ) Explicitly defining fields can provide extra information about an argument, either for the command-line interface, the model schema or features such as complex validation. Info For more information about pydantic fields, see the pydantic docs .","title":"Fields"},{"location":"usage/arguments/#arguments","text":"","title":"Arguments"},{"location":"usage/arguments/#required","text":"A field defines a required argument if it has no default value, or a default value of the Ellipses ( ... ) singleton object. class Arguments ( BaseModel ): a : int b : int = ... c : int = Field () d : int = Field ( ... )","title":"Required"},{"location":"usage/arguments/#optional","text":"A field defines an optional argument if it has a default value. class Arguments ( BaseModel ): a : int = 42 b : int = Field ( 42 ) A field can also define an optional argument if it is type-hinted as Optional . This type-hinting also allows the value of None for the field. class Arguments ( BaseModel ): a : Optional [ int ] b : Optional [ int ] = None c : Optional [ int ] = Field () d : Optional [ int ] = Field ( None )","title":"Optional"},{"location":"usage/arguments/#descriptions","text":"A field can be provided with a description , which will appear in the command-line interface help message. class Arguments ( BaseModel ): a : int = Field ( description = \"this is the command-line description!\" )","title":"Descriptions"},{"location":"usage/arguments/#aliases","text":"A field can be provided with an alias , which will change the argument name in the command-line interface. class Arguments ( BaseModel ): # We want our argument to be named `class` (i.e., `--class`), but `class` # is a reserved keyword in Python. To accomplish this, we can use the Field # `alias` to override the argument name. class_argument : int = Field ( alias = \"class\" ) Tip This feature allows you to define arguments that use a reserved python keyword as the name. For example: class , continue , async . You can see the list of reserved keywords in Python at any time by typing help ( \"keywords\" ) into the Python interpreter.","title":"Aliases"},{"location":"usage/arguments/#validation","text":"When parsing command-line arguments with parser.parse_typed_args() , the raw values are parsed and validated using pydantic . The parser has different behaviours depending on whether the supplied command-line arguments are valid. Consider the following example model: class Arguments ( BaseModel ): integer : int","title":"Validation"},{"location":"usage/arguments/#success","text":"When the provided command-line arguments satisfy the pydantic model, a populated instance of the model is returned $ python3 example.py --integer 42 Arguments(integer=42)","title":"Success"},{"location":"usage/arguments/#failure","text":"When the provided command-line arguments do not satisfy the pydantic model, the ArgumentParser will provide an error to the user. For example: $ python3 example.py --integer hello usage: example.py [-h] --integer INTEGER example.py: error: 1 validation error for Arguments integer value is not a valid integer (type=type_error.integer) Note The validation error shown to the user is the same as the error that pydantic returns to the user with a ValidationError","title":"Failure"},{"location":"usage/arguments/choices/","text":"Overview pydantic-argparse provides functionality for choice arguments. A choice is a command-line argument that allows a restricted set of values. For example: --choice X or --choice Y . This section covers the following standard argparse argument functionality: # Enum Choices parser . add_argument ( \"--choice\" , choices = [ Enum . A , Enum . B , Enum . B ]) # Literal Choices parser . add_argument ( \"--choice\" , choices = [ \"A\" , \"B\" , \"C\" ]) Usage The intended usage of choice arguments is to restrict the set of valid options for the user. For example: $ python3 example.py --choice PAPER if args . choice == \"PAPER\" : # Choice PAPER ... elif args . choice == \"SCISSORS\" : # Choice SCISSORS ... elif args . choice == \"ROCK\" : # Choice ROCK ... else : # This cannot occur! # Something must have gone wrong... ... Enums Enum choices can be created by adding a pydantic Field with the type of an enum . Enum class, which contains more than one enumeration. There are different kinds of enum choice arguments, which are outlined below. Required A required enum choice argument is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Required Choice choice : Choices = Field ( description = \"this is a required choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --choice {A, B, C} required arguments: --choice {A, B, C} this is a required choice help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . This argument cannot be omitted. Optional (Default None ) An optional enum choice argument with a default of None is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Optional Choice (Default None) choice : Optional [ Choices ] = Field ( description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . Omitting this argument will set args.choice to None (the default). Optional (Default Value ) An optional enum choice argument with a default choice is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Optional Choice (Default Choices.A) choice : Choices = Field ( Choices . A , description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: Choices.A) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . Omitting this argument will set args.choice to Choices.A (the default). Literals Literal choices can be created by adding a pydantic Field with the type of typing . Literal , which contains more than one literal value. There are different kinds of literal flag arguments, which are outlined below. Required A required literal choice argument is defined as follows: class Arguments ( BaseModel ): # Required Choice choice : Literal [ \"A\" , \"B\" , \"C\" ] = Field ( description = \"this is a required choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --choice {A, B, C} required arguments: --choice {A, B, C} this is a required choice help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . This argument cannot be omitted. Optional (Default None ) An optional literal choice argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Choice (Default None) choice : Optional [ Literal [ \"A\" , \"B\" , \"C\" ]] = Field ( description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . Omitting this argument will set args.choice to None (the default). Optional (Default Value ) An optional literal choice argument with a default choice is defined as follows: class Arguments ( BaseModel ): # Optional Choice (Default \"A\") choice : Literal [ \"A\" , \"B\" , \"C\" ] = Field ( \"A\" , description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: A) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . Omitting this argument will set args.choice to \"A\" (the default).","title":"Choices"},{"location":"usage/arguments/choices/#overview","text":"pydantic-argparse provides functionality for choice arguments. A choice is a command-line argument that allows a restricted set of values. For example: --choice X or --choice Y . This section covers the following standard argparse argument functionality: # Enum Choices parser . add_argument ( \"--choice\" , choices = [ Enum . A , Enum . B , Enum . B ]) # Literal Choices parser . add_argument ( \"--choice\" , choices = [ \"A\" , \"B\" , \"C\" ])","title":"Overview"},{"location":"usage/arguments/choices/#usage","text":"The intended usage of choice arguments is to restrict the set of valid options for the user. For example: $ python3 example.py --choice PAPER if args . choice == \"PAPER\" : # Choice PAPER ... elif args . choice == \"SCISSORS\" : # Choice SCISSORS ... elif args . choice == \"ROCK\" : # Choice ROCK ... else : # This cannot occur! # Something must have gone wrong... ...","title":"Usage"},{"location":"usage/arguments/choices/#enums","text":"Enum choices can be created by adding a pydantic Field with the type of an enum . Enum class, which contains more than one enumeration. There are different kinds of enum choice arguments, which are outlined below.","title":"Enums"},{"location":"usage/arguments/choices/#required","text":"A required enum choice argument is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Required Choice choice : Choices = Field ( description = \"this is a required choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --choice {A, B, C} required arguments: --choice {A, B, C} this is a required choice help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . This argument cannot be omitted.","title":"Required"},{"location":"usage/arguments/choices/#optional-default-none","text":"An optional enum choice argument with a default of None is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Optional Choice (Default None) choice : Optional [ Choices ] = Field ( description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . Omitting this argument will set args.choice to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/choices/#optional-default-value","text":"An optional enum choice argument with a default choice is defined as follows: class Choices ( enum . Enum ): A = enum . auto () B = enum . auto () C = enum . auto () class Arguments ( BaseModel ): # Optional Choice (Default Choices.A) choice : Choices = Field ( Choices . A , description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: Choices.A) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to Choices.A . Providing an argument of --choice B will set args.choice to Choices.B . Providing an argument of --choice C will set args.choice to Choices.C . Omitting this argument will set args.choice to Choices.A (the default).","title":"Optional (Default Value)"},{"location":"usage/arguments/choices/#literals","text":"Literal choices can be created by adding a pydantic Field with the type of typing . Literal , which contains more than one literal value. There are different kinds of literal flag arguments, which are outlined below.","title":"Literals"},{"location":"usage/arguments/choices/#required_1","text":"A required literal choice argument is defined as follows: class Arguments ( BaseModel ): # Required Choice choice : Literal [ \"A\" , \"B\" , \"C\" ] = Field ( description = \"this is a required choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --choice {A, B, C} required arguments: --choice {A, B, C} this is a required choice help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . This argument cannot be omitted.","title":"Required"},{"location":"usage/arguments/choices/#optional-default-none_1","text":"An optional literal choice argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Choice (Default None) choice : Optional [ Literal [ \"A\" , \"B\" , \"C\" ]] = Field ( description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . Omitting this argument will set args.choice to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/choices/#optional-default-value_1","text":"An optional literal choice argument with a default choice is defined as follows: class Arguments ( BaseModel ): # Optional Choice (Default \"A\") choice : Literal [ \"A\" , \"B\" , \"C\" ] = Field ( \"A\" , description = \"this is an optional choice\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--choice {A, B, C}] optional arguments: --choice {A, B, C} this is an optional choice (default: A) help: -h, --help show this help message and exit Outcomes: Providing an argument of --choice A will set args.choice to \"A\" . Providing an argument of --choice B will set args.choice to \"B\" . Providing an argument of --choice C will set args.choice to \"C\" . Omitting this argument will set args.choice to \"A\" (the default).","title":"Optional (Default Value)"},{"location":"usage/arguments/commands/","text":"Overview pydantic-argparse provides functionality for commands. A command is a positional command-line argument that can be followed by its own specific subset of command-line arguments. For example: command --arg abc . This section covers the following standard argparse argument functionality: # Subparser Commands subparsers = parser . add_subparsers () command = subparsers . add_parser ( \"command\" ) command . add_argument ( ... ) Usage The intended usage of commands is to provide the user with different application behaviours, each with their own subset of arguments. For example: $ python3 example.py serve --address 127 .0.0.1 --port 8080 if args . serve : # The serve command was chosen # We have typed access to any of the command model arguments we defined # For example: `args.serve.address`, `args.serve.port`, etc. ... Pydantic Models Commands can be created by first defining a pydantic model for the command (e.g., Command ), containing its own subset of arguments. The command can then be added to the command-line interface by adding a pydantic field with the type of Optional[Command] . Despite each command itself being optional , overall a command is always required, as outlined below. Required Required commands are defined as follows: class Command1 ( BaseModel ): arg1 : str = Field ( description = \"this is sub-argument 1\" ) class Command2 ( BaseModel ): arg2 : str = Field ( description = \"this is sub-argument 2\" ) class Arguments ( BaseModel ): # Commands command1 : Optional [ Command1 ] = Field ( description = \"this is command 1\" ) command2 : Optional [ Command2 ] = Field ( description = \"this is command 2\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] {command1,command2} ... commands: {command1,command2} command1 this is command 1 command2 this is command 2 help: -h, --help show this help message and exit This Arguments model also generates command-line interfaces for each of its commands: $ python3 example.py command1 --help usage: example.py command1 [-h] --arg1 ARG1 required arguments: --arg1 ARG1 this is sub-argument 1 help: -h, --help show this help message and exit $ python3 example.py command2 --help usage: example.py command2 [-h] --arg2 ARG2 required arguments: --arg2 ARG2 this is sub-argument 2 help: -h, --help show this help message and exit Outcomes: Providing arguments of command1 --arg1 abc will set args.command1 to to Command1 ( arg1 = \"abc\" ) , and args.command2 to None . Providing arguments of command2 --arg2 xyz will set args.command2 to to Command2 ( arg2 = \"xyz\" ) , and args.command1 to None . Commands cannot be omitted.","title":"Commands"},{"location":"usage/arguments/commands/#overview","text":"pydantic-argparse provides functionality for commands. A command is a positional command-line argument that can be followed by its own specific subset of command-line arguments. For example: command --arg abc . This section covers the following standard argparse argument functionality: # Subparser Commands subparsers = parser . add_subparsers () command = subparsers . add_parser ( \"command\" ) command . add_argument ( ... )","title":"Overview"},{"location":"usage/arguments/commands/#usage","text":"The intended usage of commands is to provide the user with different application behaviours, each with their own subset of arguments. For example: $ python3 example.py serve --address 127 .0.0.1 --port 8080 if args . serve : # The serve command was chosen # We have typed access to any of the command model arguments we defined # For example: `args.serve.address`, `args.serve.port`, etc. ...","title":"Usage"},{"location":"usage/arguments/commands/#pydantic-models","text":"Commands can be created by first defining a pydantic model for the command (e.g., Command ), containing its own subset of arguments. The command can then be added to the command-line interface by adding a pydantic field with the type of Optional[Command] . Despite each command itself being optional , overall a command is always required, as outlined below.","title":"Pydantic Models"},{"location":"usage/arguments/commands/#required","text":"Required commands are defined as follows: class Command1 ( BaseModel ): arg1 : str = Field ( description = \"this is sub-argument 1\" ) class Command2 ( BaseModel ): arg2 : str = Field ( description = \"this is sub-argument 2\" ) class Arguments ( BaseModel ): # Commands command1 : Optional [ Command1 ] = Field ( description = \"this is command 1\" ) command2 : Optional [ Command2 ] = Field ( description = \"this is command 2\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] {command1,command2} ... commands: {command1,command2} command1 this is command 1 command2 this is command 2 help: -h, --help show this help message and exit This Arguments model also generates command-line interfaces for each of its commands: $ python3 example.py command1 --help usage: example.py command1 [-h] --arg1 ARG1 required arguments: --arg1 ARG1 this is sub-argument 1 help: -h, --help show this help message and exit $ python3 example.py command2 --help usage: example.py command2 [-h] --arg2 ARG2 required arguments: --arg2 ARG2 this is sub-argument 2 help: -h, --help show this help message and exit Outcomes: Providing arguments of command1 --arg1 abc will set args.command1 to to Command1 ( arg1 = \"abc\" ) , and args.command2 to None . Providing arguments of command2 --arg2 xyz will set args.command2 to to Command2 ( arg2 = \"xyz\" ) , and args.command1 to None . Commands cannot be omitted.","title":"Required"},{"location":"usage/arguments/flags/","text":"Overview pydantic-argparse provides functionality for flag arguments. A flag is a command-line argument that has no following value. For example: --flag or --no-flag . This section covers the following standard argparse argument functionality: # Boolean Flags parser . add_argument ( \"--flag\" , action = argparse . BooleanOptionalAction ) parser . add_argument ( \"--flag\" , action = \"store_true\" ) parser . add_argument ( \"--no-flag\" , action = \"store_false\" ) # Constant Flags parser . add_argument ( \"--flag\" , action = \"store_const\" , const = \"A\" ) parser . add_argument ( \"--flag\" , action = \"store_const\" , const = Enum . A ) Usage The intended usage of flags is to enable or disable features. For example: $ python3 example.py --debug if args . debug : # Set logging to DEBUG ... Booleans Boolean flags can be created by adding a pydantic Field with the type of bool . There are different kinds of boolean flag arguments, which are outlined below. Required A required boolean flag is defined as follows: class Arguments ( BaseModel ): # Required Flag flag : bool = Field ( description = \"this is a required flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --flag | --no-flag required arguments: --flag, --no-flag this is a required flag help: -h, --help show this help message and exit Outcomes: Providing an argument of --flag will set args.flag to True . Providing an argument of --no-flag will set args.flag to False . This argument cannot be omitted. Optional (Default False ) An optional boolean flag with a default of False is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default False) flag : bool = Field ( False , description = \"this is an optional flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--flag] optional arguments: --flag this is an optional flag (default: False) help: -h, --help show this help message and exit Outcomes: Providing an argument of --flag will set args.flag to True . Omitting this argument will set args.flag to False (the default). Optional (Default True ) An optional boolean flag with a default of True is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default True) flag : bool = Field ( True , description = \"this is an optional flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-flag] optional arguments: --no-flag this is an optional flag (default: True) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-flag will set args.flag to False . Omitting this argument will set args.flag to True (the default). Enums Enum flags can be created by adding a pydantic Field with the type of an enum . Enum class, which contains only one enumeration. There are different kinds of enum flag arguments, which are outlined below. Optional (Default None ) An optional enum flag with a default of None is defined as follows: class Constant ( enum . Enum ): VALUE = enum . auto () class Arguments ( BaseModel ): # Optional Flag (Default None) constant : Optional [ Constant ] = Field ( description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--constant] optional arguments: --constant this is a constant flag (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --constant will set args.constant to Constant.VALUE . Omitting this argument will set args.constant to None (the default). Optional (Default Constant ) An optional enum flag with a constant default value is defined as follows: class Constant ( enum . Enum ): VALUE = enum . auto () class Arguments ( BaseModel ): # Optional Flag (Default Constant.VALUE) constant : Optional [ Constant ] = Field ( Constant . VALUE , description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-constant] optional arguments: --no-constant this is a constant flag (default: Constant.VALUE) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-constant will set args.constant to None . Omitting this argument will set args.constant to Constant.VALUE (the default). Literals Literal flags can be created by adding a pydantic Field with the type of typing . Literal , which contains only one literal value. There are different kinds of literal flag arguments, which are outlined below. Optional (Default None ) An optional literal flag with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default None) constant : Optional [ Literal [ \"VALUE\" ]] = Field ( description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--constant] optional arguments: --constant this is a constant flag (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --constant will set args.constant to \"VALUE\" . Omitting this argument will set args.constant to None (the default). Optional (Default Constant ) An optional literal flag with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default \"VALUE\") constant : Optional [ Literal [ \"VALUE\" ]] = Field ( \"VALUE\" , description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-constant] optional arguments: --no-constant this is a constant flag (default: VALUE) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-constant will set args.constant to None . Omitting this argument will set args.constant to \"VALUE\" (the default).","title":"Flags"},{"location":"usage/arguments/flags/#overview","text":"pydantic-argparse provides functionality for flag arguments. A flag is a command-line argument that has no following value. For example: --flag or --no-flag . This section covers the following standard argparse argument functionality: # Boolean Flags parser . add_argument ( \"--flag\" , action = argparse . BooleanOptionalAction ) parser . add_argument ( \"--flag\" , action = \"store_true\" ) parser . add_argument ( \"--no-flag\" , action = \"store_false\" ) # Constant Flags parser . add_argument ( \"--flag\" , action = \"store_const\" , const = \"A\" ) parser . add_argument ( \"--flag\" , action = \"store_const\" , const = Enum . A )","title":"Overview"},{"location":"usage/arguments/flags/#usage","text":"The intended usage of flags is to enable or disable features. For example: $ python3 example.py --debug if args . debug : # Set logging to DEBUG ...","title":"Usage"},{"location":"usage/arguments/flags/#booleans","text":"Boolean flags can be created by adding a pydantic Field with the type of bool . There are different kinds of boolean flag arguments, which are outlined below.","title":"Booleans"},{"location":"usage/arguments/flags/#required","text":"A required boolean flag is defined as follows: class Arguments ( BaseModel ): # Required Flag flag : bool = Field ( description = \"this is a required flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --flag | --no-flag required arguments: --flag, --no-flag this is a required flag help: -h, --help show this help message and exit Outcomes: Providing an argument of --flag will set args.flag to True . Providing an argument of --no-flag will set args.flag to False . This argument cannot be omitted.","title":"Required"},{"location":"usage/arguments/flags/#optional-default-false","text":"An optional boolean flag with a default of False is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default False) flag : bool = Field ( False , description = \"this is an optional flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--flag] optional arguments: --flag this is an optional flag (default: False) help: -h, --help show this help message and exit Outcomes: Providing an argument of --flag will set args.flag to True . Omitting this argument will set args.flag to False (the default).","title":"Optional (Default False)"},{"location":"usage/arguments/flags/#optional-default-true","text":"An optional boolean flag with a default of True is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default True) flag : bool = Field ( True , description = \"this is an optional flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-flag] optional arguments: --no-flag this is an optional flag (default: True) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-flag will set args.flag to False . Omitting this argument will set args.flag to True (the default).","title":"Optional (Default True)"},{"location":"usage/arguments/flags/#enums","text":"Enum flags can be created by adding a pydantic Field with the type of an enum . Enum class, which contains only one enumeration. There are different kinds of enum flag arguments, which are outlined below.","title":"Enums"},{"location":"usage/arguments/flags/#optional-default-none","text":"An optional enum flag with a default of None is defined as follows: class Constant ( enum . Enum ): VALUE = enum . auto () class Arguments ( BaseModel ): # Optional Flag (Default None) constant : Optional [ Constant ] = Field ( description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--constant] optional arguments: --constant this is a constant flag (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --constant will set args.constant to Constant.VALUE . Omitting this argument will set args.constant to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/flags/#optional-default-constant","text":"An optional enum flag with a constant default value is defined as follows: class Constant ( enum . Enum ): VALUE = enum . auto () class Arguments ( BaseModel ): # Optional Flag (Default Constant.VALUE) constant : Optional [ Constant ] = Field ( Constant . VALUE , description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-constant] optional arguments: --no-constant this is a constant flag (default: Constant.VALUE) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-constant will set args.constant to None . Omitting this argument will set args.constant to Constant.VALUE (the default).","title":"Optional (Default Constant)"},{"location":"usage/arguments/flags/#literals","text":"Literal flags can be created by adding a pydantic Field with the type of typing . Literal , which contains only one literal value. There are different kinds of literal flag arguments, which are outlined below.","title":"Literals"},{"location":"usage/arguments/flags/#optional-default-none_1","text":"An optional literal flag with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default None) constant : Optional [ Literal [ \"VALUE\" ]] = Field ( description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--constant] optional arguments: --constant this is a constant flag (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --constant will set args.constant to \"VALUE\" . Omitting this argument will set args.constant to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/flags/#optional-default-constant_1","text":"An optional literal flag with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Flag (Default \"VALUE\") constant : Optional [ Literal [ \"VALUE\" ]] = Field ( \"VALUE\" , description = \"this is a constant flag\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--no-constant] optional arguments: --no-constant this is a constant flag (default: VALUE) help: -h, --help show this help message and exit Outcomes: Providing an argument of --no-constant will set args.constant to None . Omitting this argument will set args.constant to \"VALUE\" (the default).","title":"Optional (Default Constant)"},{"location":"usage/arguments/regular/","text":"Overview pydantic-argparse provides functionality for regular arguments. A regular argument is a command-line argument that is followed by exactly one value. For example: --arg hello , --arg 123 or --arg 42.0 . This section covers the following standard argparse argument functionality: parser . add_argument ( \"--argument\" , type = T ) Usage The intended usage of regular arguments is to capture and validate a value from the user for the application. For example: $ python3 example.py --name SupImDos # We can use the validated command-line arguments in the application print ( f \"Hello { args . name } !\" ) Singular Types Regular arguments can be created by adding a pydantic Field with any type that takes \"singular\" values. Some examples of simple \"singular\" inbuilt types: str int float dict Info For more information about simple inbuilt types, see the pydantic docs Note pydantic-argparse handles some types specially , such as: collections.abc.Container (e.g., list , tuple , set ) bool enum.Enum typing.Literal pydantic.BaseModel The special behaviours of these types are addressed in the following sections. Any type that is able to be validated by pydantic can be used. This allows for advanced argument types, for example: pydantic.FilePath pydantic.EmailStr pydantic.AnyUrl pydantic.IPvAnyAddress Info For more information about advanced pydantic types, see the pydantic docs There are different kinds of regular arguments, which are outlined below. Required A required regular singular argument is defined as follows: class Arguments ( BaseModel ): # Required Singular Argument # Note: `int` is just an example, any singular type could be used arg : int = Field ( description = \"this is a required singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --arg ARG required arguments: --arg ARG this is a required singular argument help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 42 will set args.arg to 42 . This argument cannot be omitted. Optional (Default None ) An optional regular singular argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Singular Argument # Note: `int` is just an example, any singular type could be used arg : Optional [ int ] = Field ( description = \"this is an optional singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG] optional arguments: --arg ARG this is a required singular argument (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 42 will set args.arg to 42 . Omitting this argument will set args.arg to None (the default). Optional (Default Value ) An optional container variadic argument with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Singular Argument # Note: `int` is just an example, any singular type could be used arg : int = Field ( 42 , description = \"this is an optional singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG] optional arguments: --arg ARG this is a required singular argument (default: 42) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 7 will set args.arg to 7 . Omitting this argument will set args.arg to 42 (the default).","title":"Regular"},{"location":"usage/arguments/regular/#overview","text":"pydantic-argparse provides functionality for regular arguments. A regular argument is a command-line argument that is followed by exactly one value. For example: --arg hello , --arg 123 or --arg 42.0 . This section covers the following standard argparse argument functionality: parser . add_argument ( \"--argument\" , type = T )","title":"Overview"},{"location":"usage/arguments/regular/#usage","text":"The intended usage of regular arguments is to capture and validate a value from the user for the application. For example: $ python3 example.py --name SupImDos # We can use the validated command-line arguments in the application print ( f \"Hello { args . name } !\" )","title":"Usage"},{"location":"usage/arguments/regular/#singular-types","text":"Regular arguments can be created by adding a pydantic Field with any type that takes \"singular\" values. Some examples of simple \"singular\" inbuilt types: str int float dict Info For more information about simple inbuilt types, see the pydantic docs Note pydantic-argparse handles some types specially , such as: collections.abc.Container (e.g., list , tuple , set ) bool enum.Enum typing.Literal pydantic.BaseModel The special behaviours of these types are addressed in the following sections. Any type that is able to be validated by pydantic can be used. This allows for advanced argument types, for example: pydantic.FilePath pydantic.EmailStr pydantic.AnyUrl pydantic.IPvAnyAddress Info For more information about advanced pydantic types, see the pydantic docs There are different kinds of regular arguments, which are outlined below.","title":"Singular Types"},{"location":"usage/arguments/regular/#required","text":"A required regular singular argument is defined as follows: class Arguments ( BaseModel ): # Required Singular Argument # Note: `int` is just an example, any singular type could be used arg : int = Field ( description = \"this is a required singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --arg ARG required arguments: --arg ARG this is a required singular argument help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 42 will set args.arg to 42 . This argument cannot be omitted.","title":"Required"},{"location":"usage/arguments/regular/#optional-default-none","text":"An optional regular singular argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Singular Argument # Note: `int` is just an example, any singular type could be used arg : Optional [ int ] = Field ( description = \"this is an optional singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG] optional arguments: --arg ARG this is a required singular argument (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 42 will set args.arg to 42 . Omitting this argument will set args.arg to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/regular/#optional-default-value","text":"An optional container variadic argument with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Singular Argument # Note: `int` is just an example, any singular type could be used arg : int = Field ( 42 , description = \"this is an optional singular argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG] optional arguments: --arg ARG this is a required singular argument (default: 42) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 7 will set args.arg to 7 . Omitting this argument will set args.arg to 42 (the default).","title":"Optional (Default Value)"},{"location":"usage/arguments/variadic/","text":"Overview pydantic-argparse provides functionality for variadic arguments. A variadic argument is a command-line argument that is followed by one or more values. For example: --variadic a b c or --variadic 1 2 3 4 5 6 . This section covers the following standard argparse argument functionality: parser . add_argument ( \"--variadic\" , nargs = \"+\" ) Usage The intended usage of variadic arguments is to capture multiple values for an argument. For example: $ python3 example.py --files a.txt b.txt c.txt for file in args . files : # We can iterate through all of the values provided by the user ... Container Types Variadic arguments can be created by adding a pydantic Field with any type that is a collections . abc . Container type. For example: list[T] tuple[T] set[T] frozenset[T] deque[T] There are different kinds of container variadic arguments, which are outlined below. Required A required container variadic argument is defined as follows: class Arguments ( BaseModel ): # Required Container Argument # Note: `list[int]` is just an example, any container type could be used arg : list [ int ] = Field ( description = \"this is a required variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --arg ARG [ARG ...] required arguments: --arg ARG [ARG ...] this is a required variadic argument help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . This argument cannot be omitted. Optional (Default None ) An optional container variadic argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Container Argument # Note: `list[int]` is just an example, any container type could be used arg : Optional [ list [ int ]] = Field ( description = \"this is an optional variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG [ARG ...]] optional arguments: --arg ARG [ARG ...] this is a required variadic argument (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . Omitting this argument will set args.arg to None (the default). Optional (Default Value ) An optional container variadic argument with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Container Argument # Note: `list[int]` is just an example, any container type could be used arg : list [ int ] = Field ([ 4 , 5 , 6 ], description = \"this is an optional variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG [ARG ...]] optional arguments: --arg ARG [ARG ...] this is an optional variadic argument (default: [4, 5, 6]) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . Omitting this argument will set args.arg to [4, 5, 6] (the default).","title":"Variadic"},{"location":"usage/arguments/variadic/#overview","text":"pydantic-argparse provides functionality for variadic arguments. A variadic argument is a command-line argument that is followed by one or more values. For example: --variadic a b c or --variadic 1 2 3 4 5 6 . This section covers the following standard argparse argument functionality: parser . add_argument ( \"--variadic\" , nargs = \"+\" )","title":"Overview"},{"location":"usage/arguments/variadic/#usage","text":"The intended usage of variadic arguments is to capture multiple values for an argument. For example: $ python3 example.py --files a.txt b.txt c.txt for file in args . files : # We can iterate through all of the values provided by the user ...","title":"Usage"},{"location":"usage/arguments/variadic/#container-types","text":"Variadic arguments can be created by adding a pydantic Field with any type that is a collections . abc . Container type. For example: list[T] tuple[T] set[T] frozenset[T] deque[T] There are different kinds of container variadic arguments, which are outlined below.","title":"Container Types"},{"location":"usage/arguments/variadic/#required","text":"A required container variadic argument is defined as follows: class Arguments ( BaseModel ): # Required Container Argument # Note: `list[int]` is just an example, any container type could be used arg : list [ int ] = Field ( description = \"this is a required variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] --arg ARG [ARG ...] required arguments: --arg ARG [ARG ...] this is a required variadic argument help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . This argument cannot be omitted.","title":"Required"},{"location":"usage/arguments/variadic/#optional-default-none","text":"An optional container variadic argument with a default of None is defined as follows: class Arguments ( BaseModel ): # Optional Container Argument # Note: `list[int]` is just an example, any container type could be used arg : Optional [ list [ int ]] = Field ( description = \"this is an optional variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG [ARG ...]] optional arguments: --arg ARG [ARG ...] this is a required variadic argument (default: None) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . Omitting this argument will set args.arg to None (the default).","title":"Optional (Default None)"},{"location":"usage/arguments/variadic/#optional-default-value","text":"An optional container variadic argument with a constant default value is defined as follows: class Arguments ( BaseModel ): # Optional Container Argument # Note: `list[int]` is just an example, any container type could be used arg : list [ int ] = Field ([ 4 , 5 , 6 ], description = \"this is an optional variadic argument\" ) This Arguments model generates the following command-line interface: $ python3 example.py --help usage: example.py [-h] [--arg ARG [ARG ...]] optional arguments: --arg ARG [ARG ...] this is an optional variadic argument (default: [4, 5, 6]) help: -h, --help show this help message and exit Outcomes: Providing an argument of --arg 1 will set args.arg to [1] . Providing an argument of --arg 1 2 3 will set args.arg to [1, 2, 3] . Omitting this argument will set args.arg to [4, 5, 6] (the default).","title":"Optional (Default Value)"}]}